

来自UJN数科20级龚奕天前辈

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cctype>
#include <iostream>
#include <cassert>
#include <queue>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <array>
#include <functional>
#include <bitset>
using namespace std;
typedef long long ll;
const ll MOD = 1e9 + 7;
template <typename T> inline void read(T &x) {x = 0;int f = 1;char c = getchar();for(; !isdigit(c); c = getchar())if(c == '-')f = -f;for(; isdigit(c); c = getchar())x = 10 * x + c - '0';x *= f;}
template <typename T> inline void write(T x) {if(x < 0)x = -x, putchar('-');if(x >= 10)write(x / 10);putchar(x % 10 + '0');}
template <typename T> inline void ckmin(T &x, T y) {if(y < x) x = y;}
template <typename T> inline void ckmax(T &x, T y) {if(x < y) x = y;}
template <typename T> inline void mod(T &x) {x %= MOD;if(x < 0) x += MOD;}
#define SZ(x) (int)x.size()
#define int128 __int128
#define VNAME(value) (#value)
#define de(a)  cerr << VNAME(a) << " = " << a << "  "
#define de2(a) cerr << VNAME(a) << " = " << a << "\n"
ll qpow(ll a, ll b, ll p = MOD) {a = (a % p + p) % p;ll rt = 1 % p;assert(b >= 0);while(b) {if(b & 1)rt = rt * a % p;b >>= 1;a = a * a % p;}return rt;}
//head
 
// 2-SAT
 
int main() {
  int n, m;
  read(n), read(m);
  vector<vector<int>> e(2 * n);
  auto add = [&](int a, int b) {
    e[a].push_back(b);
  };
  while(m --) {
    int i, a, j, b;
    read(i), read(a), read(j), read(b);
    i --, j --;
    add(2 * i + !a, 2 * j + b);
    add(2 * j + !b, 2 * i + a);
  }
  vector<int> dfn(2 * n), stk(2 * n), id(2 * n), low(2 * n);
  vector<bool> in_stk(2 * n);
  int ti = 0, scc_cnt = 0, top = 0;
  function<void(int)> Tarjan = [&](int u) {
    dfn[u] = low[u] = ++ti;
    stk[++top] = u;
    in_stk[u] = true;
    for(auto j:e[u]) {
      if(!dfn[j]) {
        Tarjan(j);
        ckmin(low[u], low[j]);
      } else if(in_stk[j]) {
        ckmin(low[u], dfn[j]);
      }
    }
    if(dfn[u] == low[u]) {
      ++scc_cnt;
      int y;
      do {
        y = stk[top --];
        in_stk[y] = false;
        id[y] = scc_cnt;
      } while(y != u);
    }
  };
  for(int i = 0; i < 2 * n; i ++) {
    if(!dfn[i])
      Tarjan(i);
  }
 
  for(int i = 0; i < n; i ++) {
    if(id[2 * i] == id[2 * i + 1])
      return puts("IMPOSSIBLE"), 0;
  }
  puts("POSSIBLE");
  vector<int> ans(n);
  for(int i = 0; i < n; i ++) {
    ans[i] = id[2 * i] < id[2 * i + 1] ? 0 : 1;
  }
  for(auto j:ans)
    printf("%d ", j);
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//BigInt高精度 不带负数
 
#define T int
 
struct BigInt {
  vector<short> a;// a[0]最低位 a.back()最高位
  BigInt() {
    a.clear();
  }
  BigInt(T c) {
    a.clear();
    while(c) {
      a.push_back(c % 10);
      c /= 10;
    }
    if(a.size() == 0)
      a.push_back(0);
  }
  void setpos(int x, int t) { // x * pow(10, t)  t个0
    a.clear();
    assert(t >= 0);
    if(x == 0)
      a.push_back(0);
    else {
      for(int i = 0; i < t; i ++)
        a.push_back(t);
      a.push_back(x);
    }
  }
  void add_digit(int c) {
    a.push_back(c);
  }
  void pop_digit() {
    assert((int)a.size() > 0);
    a.pop_back();
  }
  int digits()const {
    return (int)a.size();
  }
  short& operator[](int x) {
    assert(x >= 0 && x < (int)a.size());
    return a[x];
  }
  void scan() {
    string str;
    cin >> str;
    a.clear();
    for(auto c : str)
      a.push_back(c - '0');
    reverse(a.begin(), a.end());
  }
  void print() {
    for(int i = (int)a.size() - 1; i >= 0; i --)
      printf("%d", a[i]);
  }
};
 
bool operator < (BigInt& a, BigInt &b) {
  if(a.digits() != b.digits())
    return a.digits() < b.digits();
  int n = a.digits();
  for(int i = n - 1; i >= 0; i --) {
    if(a[i] != b[i])
      return a[i] < b[i];
  }
  return false;
}
 
bool operator == (BigInt &a, BigInt b) {
  if(a.digits() != b.digits())
    return false;
  int n = a.digits();
  for(int i = n - 1; i >= 0; i --) {
    if(a[i] != b[i])
      return false;
  }
  return true;
}
 
bool operator <= (BigInt &a, BigInt &b) {
  return a < b || a == b;
}
 
BigInt operator+(BigInt &a, BigInt b) {
  BigInt c;
  int t = 0;
  int n = a.digits(), m = b.digits();
  for(int i = 0; i < n || i < m; i ++) {
    if(i < n)
      t += a[i];
    if(i < m)
      t += b[i];
    c.add_digit(t % 10);
    t /= 10;
  }
  while(t) {
    c.add_digit(t % 10);
    t /= 10;
  }
 
  if(c.digits() == 0)
    c.add_digit(0);
  while(c.digits() > 1 && c.a.back() == 0 )
    c.a.pop_back();
  return c;
}
 
BigInt operator-(BigInt &a, BigInt b) {
  assert(!(a < b));
  BigInt c;
  int t = 0;
  int n = a.digits(), m = b.digits();
  for(int i = 0; i < n || i < m; i ++) {
    if(i < n)
      t = a[i] - t;
    else
      t = 0 - t;
    if(i < m)
      t -= b[i];
    int r = t % 10;
    if(r < 0)
      r += 10;
    if(t < 0)
      t = 1;
    else
      t = 0;
    c.add_digit(r);
  }
  assert(t == 0);
  if(c.digits() == 0)
    c.add_digit(0);
  while(c.digits() > 1 && c.a.back() == 0 )
    c.a.pop_back();
  return c;
}
 
BigInt operator*(BigInt& a, T b) {
  BigInt c;
  T t = 0;
  int n = a.digits();
  for(int i = 0; i < n; i ++) {
    t += a[i] * b;
    c.add_digit(t % 10);
    t /= 10;
  }
  while(t) {
    c.add_digit(t % 10);
    t /= 10;
  }
  if(c.digits() == 0)
    c.add_digit(0);
  while(c.digits() > 1 && c.a.back() == 0 )
    c.a.pop_back();
  return c;
}
BigInt operator/(BigInt& a, T b) {
  BigInt c;
  T t = 0;
  int n = a.digits();
  for(int i = n - 1; i >= 0; i --) {
    t = t * 10 + a[i];
    int r = t / b;
    c.add_digit(r);
    t -= b * r;
  }
  reverse(c.a.begin(), c.a.end());
  if(c.digits() == 0)
    c.add_digit(0);
  while(c.digits() > 1 && c.a.back() == 0)
    c.pop_digit();
  return c;
}
T operator%(BigInt& a, T b) {
  T r = 0;
  int n = a.digits();
  for(int i = n - 1; i >= 0; i --)
    r = (r * 10 + a[i]) % b;
  return r;
}
 
T toSmall(BigInt &a) {
  T res = 0;
  int n = a.digits();
  for (int i = n - 1; i >= 0; i --)
    res = res * 10 + a[i];
  return res;
}
 
BigInt gcd(BigInt &a, BigInt &b) { //极端数据会挂，不靠谱，需要压位高精 不会写
  BigInt d;
  int ti = 0;
  while(1) {
    if(a[0] == 0 && a.digits() == 1) { // a = 0
      d = b;
      break;
    } else if(b[0] == 0 && b.digits() == 1) { // b = 0
      d = a;
      break;
    }
    if(a[0] % 2 == 0 && b[0] % 2 == 0) {
      a = a / 2, b = b / 2;
      ti ++;
    } else if(a[0] % 2 == 0) {
      a = a / 2;
    } else if(b[0] % 2 == 0) {
      b = b / 2;
    } else if(a < b) {
      b = b - a;
    } else {
      a = a - b;
    }
  }
  int c = 1;
  for (int i = 1; i <= ti; ) {
    c = 1;
    while(i <= ti && 1LL * c * 2 <= 2e9)
      c *= 2, i ++;
    d = d * c;
  }
  return d;
}
 
#undef T
 
 
 
 
 
 
 
 
 
 
 
//高精度除  常数较小版本
 
 
vector<int> Div(vector<int> &a,int b,int &r) { //a[0]最低位，a[a.size() - 1]最高位
  r = 0;
  vector<int> rt;
  for(int i = (int)a.size() - 1; i >= 0; i --) {
    r = r * 10 + a[i];
    rt.push_back(r / b);
    r %= b;
  }
  reverse(rt.begin(),rt.end());
  while(rt.size() >= 2 && rt.back() == 0)rt.pop_back();
  return rt;// rt : rt[0] 最低位，rt[rt.size() - 1]最高位
}
 
int main() {
  string str;
  cin >> str;
  vector<int>a(str.size(),0);
  for(int i = (int)a.size() - 1,j = 0; i >= 0; i --,j ++)
    a[i] = str[j] - '0';
  int b;
  cin >> b;
  int r;
  auto ans = Div(a,b,r);
  for(int i = (int)ans.size() - 1; i >= 0; i --)cout << ans[i];
  cout << "\n" << r;
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
//Binom组合数
const int N = 2e6 + 22;
// 注意 MOD
struct Comb {
  int n;
  ll fac[N], invfac[N];
  void init(int _n = 2e6) {
    n = _n;
    fac[0] = 1;
    for(int i = 1; i <= n; i ++)
      fac[i] = fac[i - 1] * i % MOD;
    invfac[n] = qpow(fac[n], MOD - 2);
    for(int i = n - 1; i >= 1; i --)
      invfac[i] = invfac[i + 1] * (i + 1) % MOD;
    invfac[0] = 1;
  }
  ll Binom(ll a, ll b) {
    assert(n >= a && n >= b && a >= 0 && b >= 0);
    if(a < b)
      return 0;
    return fac[a] * invfac[b] % MOD * invfac[a - b] % MOD;
  }
  ll C(ll a, ll b) { // Lucas
    assert(a >= 0 && b >= 0);
    ll ret = 0;
    if(a < b)
      ret = 0;
    else if(a < MOD)
      ret = Binom(a, b);
    else
      ret = Binom(a % MOD, b % MOD) * C(a / MOD, b / MOD) % MOD;
    return ret;
  }
} Co;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//deque
 
template<typename T>
class Deque { // 不支持头部插入
#define MAX ((int)1e6)
    T q[MAX];
  private:
    int hh = 1;
    int tt = 0;
  public:
    Deque() {
      hh = 1, tt = 0;
    }
    void clear() {
      hh = 1, tt = 0;
    }
    bool empty()const {
      return hh <= tt;
    }
    int size()const {
      return tt - hh + 1;
    }
    void push_back(T x) {
      assert(tt < MAX);
      q[++tt] = x;
    }
    void pop_back() {
      assert(hh <= tt);
      --tt;
    }
    void pop_front() {
      assert(hh <= tt);
      ++hh;
    }
    T front()const {
      assert(hh <= tt);
      return q[hh];
    }
    T back()const {
      assert(hh <= tt);
      return q[tt];
    }
#undef MAX
};
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Dirichlet 卷积 快速幂
template <typename T> inline void mod(T &x) {
  x %= MOD;
  if(x < 0)x += MOD;
}
vector<ll> operator * (vector<ll> &f, vector<ll> &g) { //太慢了
  int n = SZ(f);
  assert(SZ(g) == n);
  vector<ll> h(n);
  for (int i = 1; i < n; i ++)
    for (int j = 1; i * j < n; j ++)
      h[i * j] += f[i] * g[j] % MOD, mod(h[i * j]);
  return h;
}
void show(vector<ll> a) {
  printf("show ");
  for (int i = 1; i < SZ(a); i ++)
    cout << a[i] << " ";
  cout << "\n";
}
vector<ll> qpow(vector<ll> &a, ll b) { // a变了
  assert(b >= 0);
  int n = SZ(a);
  vector<ll> res(n);
  res[1] = 1;
  while(b) {
    if(b & 1)
      res = res * a;
    b >>= 1;
    a = a * a;
  }
  return res;
}
 
void solve() {
  int n, k;
  scanf("%d%d", &n, &k);
  vector<ll> f(n + 1), one(n + 1);
  for (int i = 1; i <= n; i ++)
    scanf("%lld", &f[i]), one[i] = 1;
  vector<ll> onek = qpow(one, k);
  vector<ll> ans = onek * f;
  for (int i = 1; i <= n; i ++)
    cout << ans[i] << " \n"[i == n];
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//Dirichlet 前缀和 后缀和
 
// a --> prefix sum of a  (sum(n) = sum of [d | n == true] * a[d])
for (int i = 1; i <= tol; i ++) {
  for (int j = 1; pr[i] * j <= n; j ++)
    a[pr[i] * j] += a[j];
}
// prefix sum of a --> a
for (int i = tol; i >= 1; i --) { // 维度从小到大和从大到小都可以
  for (int j = n / pr[i]; j >= 1; j --) {
    a[j * pr[i]] -= a[j];
  }
}
show();
 
// a --> suffix sum of a  (sum(n) = sum of [n | d == true] * a[d])
for (int i = 1; i <= tol; i ++) {
  for (int j = n / pr[i]; j >= 1; j --)
    a[j] += a[pr[i] * j];
}
// suffix sum of a --> a
for (int i = tol; i >= 1; i --) {
  for (int j = 1; pr[i] * j <= n; j ++)
    a[j] -= a[j * pr[i]];
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//DSU
class Dsu { // [1, n]
  private:
    vector<int> fa, sz;
  public:
    Dsu(int n) {
      fa.resize(n + 1), sz.resize(n + 1);
      for(int i = 1; i <= n; i ++)
        fa[i] = i, sz[i] = 1;
    }
    int Find(int u) {
      return fa[u] == u ? u : fa[u] = Find(fa[u]);
    }
    void Union(int x, int y) { // y合并到x上
      x = Find(x), y = Find(y);
      if(x == y)
        return;
      fa[y] = x;
      sz[x] += sz[y];
    }
    bool same(int x, int y) {
      return Find(x) == Find(y);
    }
    int size(int x) {
      return sz[Find(x)];
    }
    void init(int n) {
      fa.resize(n + 1), sz.resize(n + 1);
      for(int i = 1; i <= n; i ++)
        fa[i] = i, sz[i] = 1;
    }
};
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
/*euler path*/
int Euler(int n, vector<vector<int>> &e, vector<int> &d) { // index 1 ~ n
  int tol = 0;
  vector<bool> st(n + 1);
  function<void(int)> dfs = [&](int u) {
    st[u] = 1;
    tol ++;
    for(auto j:e[u]) {
      if(!st[j])
        dfs(j);
    }
  };
  dfs(1);
  int num = 0;
  for(int i = 1; i <= n; i ++)
    num += d[i] != 0;
  //特判孤立点
  //无向欧拉路存在充要条件
  //所有度非0的点连通，且度全是偶数 或n - 2个偶数
  if(tol != num)
    return 0;
  int num0 = 0, num1 = 0;
  for(int i = 1; i <= n; i ++)
    num0 += (d[i] % 2 == 0), num1 += (d[i] % 2 == 1);
  if(num0 == n)
    return 1;// euler path
  else if(num0 == n - 2 && num1 == 2)
    return 2;// euler 回路
  else
    return 0;
}
 
int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  vector<int> d(n + 1);
  vector<vector<int>> e(n + 1);
  for(int i = 1; i <= m; i ++) {
    int a, b;
    scanf("%d%d", &a, &b);
    e[a].push_back(b);
    e[b].push_back(a);
    d[a] ++, d[b] ++;
  }
  puts(Euler(n, e, d) ? "Yes" : "No");
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//exbsgs
typedef long long LL;
 
const int INF = 1e8;
 
int exgcd(int a, int b, int& x, int& y) {
  if (!b) {
    x = 1, y = 0;
    return a;
  }
  int d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
 
int bsgs(int a, int b, int p) {
  if (1 % p == b % p) return 0;
  int k = sqrt(p) + 1;
  unordered_map<int, int> ha;
  for (int i = 0, j = b % p; i < k; i ++ ) {
    ha[j] = i;
    j = (LL)j * a % p;
  }
  int ak = 1;
  for (int i = 0; i < k; i ++ ) ak = (LL)ak * a % p;
  for (int i = 1, j = ak; i <= k; i ++ ) {
    if (ha.count(j)) return i * k - ha[j];
    j = (LL)j * ak % p;
  }
  return -INF;
}
 
int exbsgs(int a, int b, int p) {
  b = (b % p + p) % p;
  if (1 % p == b % p) return 0;
  int x, y;
  int d = exgcd(a, p, x, y);
  if (d > 1) {
    if (b % d) return -INF;
    exgcd(a / d, p / d, x, y);
    return exbsgs(a, (LL)b / d * x % (p / d), p / d) + 1;
  }
  return bsgs(a, b, p);
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Excrt
 
const int N = 12;
int n;
ll a[N], b[N];
ll gcd(ll a, ll b) {
  return b == 0 ? a : gcd(b, a % b);
}
ll lcm(ll a, ll b) {
  return a / gcd(a, b) * b;
}
ll exgcd(ll a, ll b, ll &x, ll &y) {
  if(b == 0)
    return x = 1, y = 0, a;
  ll d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
bool solve_Binary_equation(ll a, ll b, ll c, ll &x ,ll & y) {
  assert(a != 0 || b != 0);
  if(c % gcd(a, b) != 0)
    return false;
  x = 0, y = 0;
  ll g = exgcd(a, b, x, y);
  /*a * x + b * y = g*/
  x *= c / g, y *= c / g;
  return true;
}
ll CRT(ll a[], ll b[], int n) { /*x == a[i] mod b[i]*/
  ll m = 1;
  ll x = 0;
  for(int i = 1; i <= n; i ++) {
    /*x = x0 + s * m == a[i] mod(b[i])
    <==> s * m + t * b[i] == a[i] - x0
    */
    ll s, t;
    ll ok = solve_Binary_equation(m, b[i], a[i] - x, s, t);
    if(!ok)
      return -1;
    x = x + s * m;
    m = lcm(m, b[i]);
    x %= m;
  }
  x = (x % m + m) % m;
  return x;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//excrt2
 
ll exgcd(ll a, ll b, ll &x, ll &y) {
  if(b == 0)
    return x = 1, y = 0, a;
  ll d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
void Merge(ll &a, ll &b, ll c, ll d) { // x == a mod b   x == c mod d
  ll x, y;
  ll g = exgcd(b, d, x, y);
  if((c - a) % g != 0)
    return a = b = -1, void();// 无解
  d /= g;
  ll t = (int128)((c - a) / g) % d * x % d;
  if(t < 0)
    t += d;
  a = b * t + a;
  b = b * d;
}
ll EXCRT(vector<pair<ll, ll>> ab) { // ab = {ai, bi}
  // x == ai mod bi
  ll A = 0, B = 1;
  int n = SZ(ab);
  for (int i = 0; i < n; i ++) {
    Merge(A, B, ab[i].first, ab[i].second);
    if(A == -1 && B == -1)
      return -1;
//    de(i), de2(A);
  }
  return A;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//exeuler
 
 
/*扩展欧拉定理*/
/*
pow(a,b) % m = a ^ min(b, b % phi(m) + phi(m))
(1),pow(a,b) % m when b < phi(m)
(2),pow(a,b % phi(m) + phi(m)) % m when b >= phi(m)
*/
 
ll toD(string str) {
  ll rt = 0;
  for(auto c:str)
    rt = rt * 10 + c - '0';
  return rt;
}
ll a,m,b;
string B;
ll phi(ll m) {
  ll ans = m;
  for(ll i = 2; i * i <= m; i ++) {
    if(m % i == 0) {
      ans = ans * (i - 1);
      ans /= i;
      while(m % i == 0)m /= i;
    }
  }
  if(m > 1) {
    ans = ans * (m - 1);
    ans /= m;
  }
  return ans;
}
int main() {
  read(a),read(m);
  cin >> B;
  if(B.size() < 18) {
    b = toD(B);
    cout << (long long)qpow(a,b,m);
  } else {
    ll r = 0;
    ll ph = phi(m);
    for(auto c:B) {
      r = r * 10 + c - '0';
      r %= ph;
    }
    cout << (long long)qpow(a,r + ph,m);
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//exgcd  逆元
 
ll exgcd(ll a, ll b, ll& x, ll& y) {
  if (b == 0) {
    x = 1, y = 0;
    return a;
  }
  ll d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
ll inv(ll a, ll b) {
  ll x = 0, y = 0;
  exgcd(a, b, x, y);
  x = x % b;
  if (x < 0) x += b;
  return x;
}
 
int main() {
  ll n,p;
  cin >> n >> p;
  for(int i = 1; i <= n; i ++)cout << inv(i, p) << "\n";
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//exlucas
 
ll exgcd(ll a, ll b, ll &x, ll &y) {
  if(b == 0)
    return x = 1, y = 0, a;
  ll d = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return d;
}
void Merge(ll &a, ll &b, ll c, ll d) { // x == a mod b   x == c mod d
  ll x, y;
  ll g = exgcd(b, d, x, y);
  if((c - a) % g != 0)
    return a = b = -1, void();// 无解
  d /= g;
  ll t = (int128)((c - a) / g) % d * x % d;
  if(t < 0)
    t += d;
  a = b * t + a;
  b = b * d;
}
ll EXCRT(vector<pair<ll, ll>> ab) { // ab = {ai, bi}
  // x == ai mod bi
  ll A = 0, B = 1;
  int n = SZ(ab);
  for (int i = 0; i < n; i ++) {
    Merge(A, B, ab[i].first, ab[i].second);
    if(A == -1 && B == -1)
      return -1;
  }
  return A;
}
 
namespace Extend_Lucas {
  const int MN = 1e6 + 22;
  int m;//模数
  int M, phipe;
  vector<pair<int, int>> x; // p pe
  ll fac[30][MN];
  ll cntp, cnts;
  ll calc(ll a, int p, int pe, int w, int i) {
    ll val = 1;
    while (a) {
      cntp += (a / p) * w;
      cnts += (a / pe) * w;
      val = val * fac[i][a % pe] % pe;
      a /= p;
    }
    return val;
  }
 
  ll binom(ll a, ll b, int p, int pe, int i) {
    cntp = 0;
    cnts = 0;
    ll f1 = calc(a, p, pe, 1, i);
    ll f2 = calc(b, p, pe, -1, i);
    ll f3 = calc(a - b, p, pe, -1, i);
    ll v1 = f1 * qpow(f2 * f3 % pe, phipe - 1, pe) % pe;
    ll v2 = qpow(p, cntp, pe);
    ll v3 = qpow(fac[i][pe], cnts, pe);
    return v1 * v2 % pe * v3 % pe;
  }
  void pre_x_fac(int m) {
    x.clear();
    for (int i = 2; 1LL * i * i <= m; i++) if (m % i == 0) {
        int p = i, pe = 1;
        while (m % i == 0) m /= i, pe *= i;
        assert(pe < MN);
        x.push_back({p, pe});
      }
    if(m > 1)
      x.push_back({m, m});
 
    for (int i = 0; i < SZ(x); i ++) {
      int p = x[i].first, pe = x[i].second;
      fac[i][0] = 1;
      for (int j = 1; j <= pe; j++) {
        if (j % p == 0) fac[i][j] = fac[i][j - 1];
        else fac[i][j] = fac[i][j - 1] * j % pe;
      }
    }
  }
  void Init(int _m) { //模数
    m = _m;
    M = m;
    pre_x_fac(m);
  }
 
  ll exLucas(ll a, ll b) {
    assert(m);
    vector<pair<ll, ll>> ab;
    for (int i = 0; i < SZ(x); i ++) {
      ll p = x[i].first, pe = x[i].second;
      phipe = pe / p * (p - 1);
      ab.push_back({binom(a, b, p, pe, i) ,pe});
    }
    return EXCRT(ab);
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Frac
 
class Frac { // a / b
  private:
    ll a = 0;
    ll b = 1;
  public:
    Frac() {
      a = 0, b = 1;
    }
    Frac(ll x) {
      a = x, b = 1;
    }
    Frac(ll _a, ll _b) {
      a = _a, b = _b, assert(b != 0);
    }
    ll geta()const {
      return a;
    }
    ll getb()const {
      return b;
    }
 
    friend Frac operator + (const Frac& x, const Frac& y) {
      ll p = x.geta() * y.getb() + x.getb() * y.geta();
      ll q = x.getb() * y.getb();
      ll g = __gcd(p, q);
      p /= g, q /= g;
      Frac z(p, q);
      return z;
    }
 
    friend Frac operator - (const Frac& x, const Frac& y) {
      ll p = x.geta() * y.getb() - x.getb() * y.geta();
      ll q = x.getb() * y.getb();
      ll g = __gcd(p, q);
      p /= g, q /= g;
      Frac z(p, q);
      return z;
    }
    friend Frac operator * (const Frac& x, const Frac& y) {
      ll p = x.geta() * y.geta();
      ll q = x.getb() * y.getb();
      ll g = __gcd(p, q);
      p /= g, q /= g;
      Frac z(p, q);
      return z;
    }
 
    friend Frac operator / (const Frac& x, const Frac& y) {
      ll p = x.geta() * y.getb();
      ll q = x.getb() * y.geta();
      ll g = __gcd(p, q);
      p /= g, q /= g;
      assert(q != 0);
      Frac z(p, q);
      return z;
    }
 
    Frac& operator=(const ll& x) {
      a = x, b = 1;
      return *this;
    }
    Frac& operator=(const Frac& x) {
      a = x.geta(), b = x.getb();
      return *this;
    }
};
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Gauss
namespace Linear_Algebra {
  vector<double> operator-(vector<double> a, vector<double> b) {
    assert(SZ(a) == SZ(b));
    vector<double> c(SZ(a));
    for (int i = 0; i < SZ(a); i ++)
      c[i] = a[i] - b[i];
    return c;
  }
  vector<double> operator*(vector<double> &a, double b) {
    vector<double> c(SZ(a));
    for (int i = 0; i < SZ(a); i ++)
      c[i] = a[i] * b;
    return c;
  }
  const double eps = 1e-8;
  void show(vector<vector<double>> &a) {
    for (auto vec : a) {
      for (auto p : vec)
        printf("%.2lf ", p);
      puts("");
    }
    puts("");
  }
  void Gauss(vector<vector<double>> &a) { // n行m列矩阵
    int n = SZ(a);
    assert(n);
    int m = SZ(a[0]);
    assert(m);// n > 0
    for (int i = 0; i < n; i ++) {
      assert(SZ(a[i]) == SZ(a[0]));
    }
    for (int r = 0, c = 0; r < n && c < m; ) {
      int k = -1;
      for (int i = r; i < n; i ++) {
        if(k == -1 || abs(a[i][c]) > abs(a[k][c]))
          k = i;
      }
      if(k == -1 || abs(a[k][c]) < eps) {
        c ++;
      } else {
        swap(a[r], a[k]);// 常数可以优化
        assert(abs(a[r][c]) > eps);
        a[r] = a[r] * (1 / a[r][c]);
        for (int i = r + 1; i < n; i ++) { //常数优化
          a[i] = a[i] - a[r] * a[i][c];
        }
        r ++, c ++;
      }
    }
    for (int r = n - 1; r >= 0; r --) {
      int c = -1;
      for (int j = 0; j < m; j ++)
        if(abs(a[r][j] - 1) < eps) {
          c = j;
          break;
        }
      if(c != -1) {
        for (int i = 0; i < r; i ++)// 常数优化
          a[i] = a[i] - a[r] * a[i][c];
      }
    }
  }
  /*
  考查系数矩阵r(A)，增广矩阵r(A,b)，以及方程组未知数个数n。
  如果系数矩阵的秩r(A)小于增广矩阵的秩r(A,b)，r(A)<r(A,b)，那么方程组无解；
  如果系统矩阵的秩小于方程组未知数个数，r(A)=r(A,b)<n，那么方程组有多个解。
  如果系统矩阵的秩等于方程组未知数个数，r(A)=r(A,b)=n，那么方程组有唯一解。
  */
  int Get_Rank_Of_Coefficient_Matrix(vector<vector<double>> A) { //系数矩阵的秩
    int n = SZ(A), m = SZ(A[0]);
    int rank = 0;
    for (int r = 0; r < n; r ++) {
      bool f = false;
      for (int c = 0; c < m - 1; c ++)
        if(abs(A[r][c]) > eps)
          f = true;
      rank += f;
    }
    return rank;
  }
  int Get_Rank_Of_Extended_Matrix(vector<vector<double>> A) { // 增广矩阵的秩
    int n = SZ(A), m = SZ(A[0]);
    int rank = 0;
    for (int r = 0; r < n; r ++) {
      bool f = false;
      for (int c = 0; c < m; c ++)
        if(abs(A[r][c]) > eps)
          f = true;
      rank += f;
    }
    return rank;
  }
  //系数矩阵A n行m列   n为方程个数， m为未知量个数
  int Linar_Equations(vector<vector<double>> A, vector<double> b, vector<double> &x) { // A * x = b
    int n = SZ(A);
    assert(n);
    assert(n == SZ(b));
    int m = SZ(A[0]);
    for (int i = 0; i < n; i ++)
      assert(m == SZ(A[i]));
    for (int i = 0; i < n; i ++)
      A[i].push_back(b[i]);
    Gauss(A);
    int rank1 = Get_Rank_Of_Coefficient_Matrix(A), rank2 = Get_Rank_Of_Extended_Matrix(A);
    x.resize(m, 0);
    if(rank1 == rank2) {
      for (int r = n - 1; r >= 0; r --) {
        for (int c = 0; c < m; c ++) {
          if(abs(A[r][c] - 1) < eps) {
            x[c] = A[r].back() / A[r][c];
            if(abs(x[c]) < eps)
              x[c] = abs(x[c]);
            break;
          }
        }
      }
      if(rank1 == m)// 秩等于未知量的个数
        return 1;//唯一解
      else
        return 2;//无穷多解， 返回 某个解
    } else
      return 0;//无解
  }
};
int main() {
  int n;
  scanf("%d", &n);
  vector<vector<double>>A(n, vector<double>(n));
  vector<double> b(n);
  for (int i = 0; i < n; i ++) {
    for (int j = 0; j < n; j ++)
      scanf("%lf", &A[i][j]);
    scanf("%lf", &b[i]);
  }
  vector<double> x;
  int res = Linear_Algebra::Linar_Equations(A, b, x);
  if(res != 1) {
    puts("No Solution");
  } else {
    for (auto p : x)
      printf("%.2lf\n", p);
  }
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//HashTable
template<typename T1, typename T2>
class HashTable {
#define MAX (1000050)
    struct Node {
      T1 key;
      T2 value;
      int ne = -1;
      Node() {}
      Node(T1 _key, T2 _value, int _ne) {
        key = _key, value = _value, ne = _ne;
      }
    };
  private:
    vector<Node> node;
    int head[MAX];
  public:
    HashTable() {
      memset(head, -1, sizeof head);
      node.clear();
    }
    void clear() {
      memset(head, -1, sizeof head);
      node.clear();
    }
    T2& operator[] (T1 key) {
      int id = Find(key);
      if(id == -1) {
        id = insert(Hash_Function(key), key, T2());
        return node[id].value;
      }
      return node[id].value;
    }
    int count(T1 key) {
      return Find(key) == -1 ? 0 : 1;
    }
  private:
    int Hash_Function(T1 key) {
      int res = key % MAX;
      if(res < 0)
        res += MAX;
      return res;
    }
    /*return insert id*/
    unsigned insert(unsigned int pos, T1 key, T2 value) {
      Node cur(key, value, head[pos]);
      node.push_back(cur);
      head[pos] = (int)node.size() - 1;
      return (int)node.size() - 1;
    }
    int Find(T1 key) {
      unsigned pos = Hash_Function(key);
      for(int i = head[pos]; ~i; i = node[i].ne) {
        if(node[i].key == key)
          return i;
      }
      return -1;
    }
 
#undef MAX
};
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//KDT(静态)
const int N = 1e5 + 22;
template<typename T, int D = 2>// 静态KD_Tree
struct KD_Tree {
  struct Point {
    T cor[D];
    T& operator[](int x) {
      return cor[x];
    }
  };
  struct Node {
    Point p;
    int id;
  } A[N];
  Point L[N], R[N];
  int id[N];//原始下标
  int ls[N], rs[N];
  int root;
  void pushup(int u, int son) {
    if(!son) return;
    for (int i = 0; i < D; i ++)
      ckmin(L[u][i], L[son][i]), ckmax(R[u][i], R[son][i]);
  }
  void pushup(int u) {
    pushup(u, ls[u]), pushup(u, rs[u]);
  }
  void Build(int &u, int l, int r, int d) {
    if(l > r)return u = 0, void();
    int mid = (l + r) >> 1;
    nth_element(A + l, A + mid, A + r + 1, [&](auto A, auto B) {
      return A.p[d] < B.p[d];
    });
    u = mid;
    L[u] = R[u] = A[u].p;
    id[u] = A[u].id;
//    printf("id = %d  -> %lld %lld\n", id[u], A[u].p[0], A[u].p[1]);
    Build(ls[u], l, u - 1, (d + 1) % D);
    Build(rs[u], u + 1, r, (d + 1) % D);
    pushup(u);
  }
  void Build(int l, int r) {
    Build(root, l, r, 0);
  }
  Point Get_Closet_Point(int u, Point P) {
    Point ans;
    for (int i = 0; i < D; i ++)
      if (P[i] < L[u][i])
        ans[i] = L[u][i];
      else if(P[i] < R[u][i])
        ans[i] = P[i];
      else
        ans[i] = R[u][i];
    return ans;
  }
  T Get_Dist(Point A, Point B) { // Euclid Distance
    T ans = 0;
    for (int i = 0; i < D; i ++)
      ans += (A[i] - B[i]) * (A[i] - B[i]);
    return ans;
  }
  T Get_Max_Possible_Dist(int u, Point P) {
    T ans = 0;
    for (int i = 0; i < D; i ++) {
      T mx = max(abs(P[i] - L[u][i]), abs(P[i] - R[u][i]));// Euclid Distance
      ans += mx * mx;
    }
    return ans;
  }
  T Get_Min_Possible_Dist(int u, Point P) {
    return Get_Dist(P, Get_Closet_Point(u, P));
  }
  void Query_Closest(T& ans, int u, int id) { // 查询u子树中与编号id的点最近的点
    if(!u)
      return;
    if(u != id)
      ckmin(ans, Get_Dist(A[u].p, A[id].p));
    if(ls[u] && rs[u]) {
      T Lmn = Get_Min_Possible_Dist(ls[u], A[id].p);
      T Rmn = Get_Min_Possible_Dist(rs[u], A[id].p);
      if(Lmn < Rmn) {
        if(ans > Lmn)
          Query_Closest(ans, ls[u], id);
        if(ans > Rmn)
          Query_Closest(ans, rs[u], id);
      } else {
        if(ans > Rmn)
          Query_Closest(ans, rs[u], id);
        if(ans > Lmn)
          Query_Closest(ans, ls[u], id);
      }
    } else if(ls[u]) {
      T Lmn = Get_Min_Possible_Dist(ls[u], A[id].p);
      if(ans > Lmn)
        Query_Closest(ans, ls[u], id);
    } else {
      T Rmn = Get_Min_Possible_Dist(rs[u], A[id].p);
      if(ans > Rmn)
        Query_Closest(ans, rs[u], id);
    }
  }
  void Query_Closest(T &ans, int id) {
    Query_Closest(ans, root, id);
  }
  void Query_Farthest(T& ans, int u, int id) { // 最远
    if(!u)
      return;
    if(u != id)
      ckmax(ans, Get_Dist(A[u].p, A[id].p));
    if(ls[u] && rs[u]) {
      T Lmx = Get_Max_Possible_Dist(ls[u], A[id].p);
      T Rmx = Get_Max_Possible_Dist(rs[u], A[id].p);
      if(Lmx > Rmx) {
        if(ans < Lmx)
          Query_Farthest(ans, ls[u], id);
        if(ans < Rmx)
          Query_Farthest(ans, rs[u], id);
      } else {
        if(ans < Rmx)
          Query_Farthest(ans, rs[u], id);
        if(ans < Lmx)
          Query_Farthest(ans, ls[u], id);
      }
    } else if(ls[u]) {
      T Lmx = Get_Max_Possible_Dist(ls[u], A[id].p);
      if(ans < Lmx)
        Query_Farthest(ans, ls[u], id);
    } else {
      T Rmx = Get_Max_Possible_Dist(rs[u], A[id].p);
      if(ans < Rmx)
        Query_Farthest(ans, rs[u], id);
    }
  }
  void Query_Farthest(T &ans, int id) {
    Query_Farthest(ans, root, id);
  }
};
KD_Tree<double, 2> T;
 
int main() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; i ++)
    scanf("%lf%lf", &T.A[i].p[0], &T.A[i].p[1]), T.A[i].id = i;
//  random_shuffle(T.A + 1, T.A + n + 1);
  T.Build(1, n);
  double mn = 1e18;
  for (int i = 1; i <= n; i ++)
    T.Query_Closest(mn, i);
  double mx = 0;
  for (int i = 1; i <= n; i ++)
    T.Query_Farthest(mx, i);
  printf("%.10lf %.10lf\n", sqrt(mn), sqrt(mx));
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//KDT(重构)
 
const int N = 2e5 + 22, D = 2;
const double Alpha = 0.75;
using T = int;
struct Po {
  T cor[D];
  T& operator[](int x) {
    return cor[x];
  }
} P[N], L[N], R[N];
int mx[N], val[N], sum[N];
int s[N];
int ls[N], rs[N], Dim[N], root, idx;
void pushup(int u, int son) {
  if(!son)
    return;
  sum[u] += sum[son];
  s[u] += s[son];
  ckmax(mx[u], mx[son]);
  for (int i = 0; i < D; i ++)
    ckmin(L[u][i], L[son][i]), ckmax(R[u][i], R[son][i]);
}
void pushup(int u) {
  s[u] = 1;
  mx[u] = val[u];
  sum[u] = val[u];
  pushup(u, ls[u]);
  pushup(u, rs[u]);
}
int tol, seq[N];
void DFS(int u) {
  if(!u)
    return;
  DFS(ls[u]);
  seq[++ tol] = u;
  DFS(rs[u]);
}
void Reb(int &u, int l, int r) {
  if(l > r)
    return u = 0, void();
  static double av[D], var[D];
  for (int i = 0; i < D; i ++) {
    av[i] = 0;
    for (int j = l; j <= r; j ++)
      av[i] += P[seq[j]][i];
    av[i] /= (r - l + 1);
  }
  for (int i = 0; i < D; i ++) {
    var[i] = 0;
    for (int j = l; j <= r; j ++)
      var[i] += (av[i] - P[seq[j]][i]) * (av[i] - P[seq[j]][i]);
  }
  int d = max_element(var, var + D) - var;
  int mid = (l + r) >> 1;
  nth_element(seq + l, seq + mid, seq + r + 1, [&](int &x, int &y) {
    return P[x][d] < P[y][d];
  });
  u = seq[mid];
  L[u] = R[u] = P[u];
  Dim[u] = d;
  Reb(ls[u], l, mid - 1);
  Reb(rs[u], mid + 1, r);
  pushup(u);
}
void Do_Reb(int &u) {
//  return;
  tol = 0;
  DFS(u);
  Reb(u, 1, tol);
}
 
bool Bad(int u) {
  return max(s[ls[u]], s[rs[u]]) > Alpha * s[u];
}
void Insert(int &u, Po &p, int v) {
  if(!u) {
    u = ++idx;
    assert(idx < N);
    ls[u] = rs[u] = 0;
    P[u] = L[u] = R[u] = p;
    mx[u] = val[u] = v;
    s[u] = 1;
    sum[u] += v;
    return;
  } else {
    int d = Dim[u];
    if(p[d] < P[u][d])
      Insert(ls[u], p, v);
    else
      Insert(rs[u], p, v);
    pushup(u);
    if(Bad(u))
      Do_Reb(u);
  }
}
 
Po Get_Closet_Po(int u, Po P) {
  Po ans;
  for (int i = 0; i < D; i ++)
    if (P[i] < L[u][i])
      ans[i] = L[u][i];
    else if(P[i] < R[u][i])
      ans[i] = P[i];
    else
      ans[i] = R[u][i];
  return ans;
}
T Get_Dist(Po A, Po B) { // Euclid Distance
  T ans = 0;
  for (int i = 0; i < D; i ++)
    ans += abs(A[i] - B[i]);
  return ans;
}
T Get_Max_Possible_Dist(int u, Po P) {
  T ans = 0;
  for (int i = 0; i < D; i ++) {
    T mx = max(abs(P[i] - L[u][i]), abs(P[i] - R[u][i]));// Euclid Distance
    ans += abs(mx);
  }
  return ans;
}
T Get_Min_Possible_Dist(int u, Po P) {
  return Get_Dist(P, Get_Closet_Po(u, P));
}
bool Cov(Po &A, Po &B) { // A在B下方
  for (int i = 0; i < D; i ++)
    if(A[i] > B[i])
      return false;
  return true;
}
int Query(int u, Po A, Po B) {
  if(!u)
    return /**/;
  else if(!(Cov(A, R[u]) && Cov(L[u], B)))
    return /**/;
  else if(Cov(A, L[u]) && Cov(R[u], B))
    return /**/;
  else {
    int res = /**/;
    if(Cov(A, P[u]) && Cov(P[u], B))
      res /**/val[u];
    res /**/ Query(ls[u], A, B);
    res /**/Query(rs[u], A, B);
    return res;
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//KMP
class KMP {
#define M ((int)2e6 + 11)
  private:
    int len = 0;
    int ne[M];// max t s.t  p[1....t] = p[n - t + 1.....n]
    char p[M];//p's index starts from 1
  public:
    void init() {
      len = 0;
    }
    void addchar(char a) {
      ++len;
      assert(len < M);
      p[len] = a;
    }
    void getnext() {
      ne[1] = 0;
      for(int i = 2, j = 0; i <= len; i ++) {
        while(j == len || (j > 0 && p[i] != p[j + 1]))
          j = ne[j];
        if(p[i] == p[j + 1])
          j ++;
        ne[i] = j;
      }
    }
    int get_len() {
      return len;
    }
    int get_next_val(int x) {
      return ne[x];
    }
    int get_back_next() {
      return ne[len];
    }
    void show_p() {
      for(int i = 1; i <= len; i ++)
        printf("%c", p[i]);
      puts("");
    }
    void show_ne() {
      for(int i = 1; i <= len; i ++)
        printf("%d", ne[i]);
      puts("");
    }
#undef M
};
const int N = 2e6 + 22;
char p[N], s[N];
int main() {
  int n, m;
  scanf("%d", &m);
  scanf("%s", p + 1);
  scanf("%d", &n);
  scanf("%s", s + 1);
  KMP kmp;
  for(int i = 1; i <= m; i ++)
    kmp.addchar(p[i]);
  kmp.addchar('#');
  for(int i = 1; i <= n; i ++)
    kmp.addchar(s[i]);
  kmp.getnext();
 
  int ed = kmp.get_len();
  int start = ed - n + 1;
  for(int i = start, j = 1; i <= ed; i ++, j ++) {
    if(kmp.get_next_val(i) == m)
      printf("%d ", j - m );
  }
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//倍增LCA
const int N =  1e6 + 22, MAXLOG = 25;
int fa[N][MAXLOG], dep[N];
vector<int> e[N];
void dfs(int u = 1, int f = 0) {
  fa[u][0] = f;
  dep[u] = dep[f] + 1;
  for(int i = 1; i <= MAXLOG - 1; i ++) {
    /*update val*/
    fa[u][i] = fa[fa[u][i - 1]][i - 1];
  }
  for(auto j : e[u]) {
    if(j == f)
      continue;
    dfs(j, u);
  }
}
int lca(int a, int b) {
  if(dep[a] < dep[b])
    swap(a, b);
  for(int i = MAXLOG - 1; i >= 0; i --) {
    if(dep[fa[a][i]] >= dep[b]) {
      /*update val*/
      a = fa[a][i];
    }
  }
  assert(dep[a] == dep[b]);
  if(a == b)
    return a;
  for(int i = MAXLOG - 1; i >= 0; i --)
    if(fa[a][i] != fa[b][i]) {
      /*update val*/
      a = fa[a][i], b = fa[b][i];
    }
  /*a - > fa[a][0]  b - > fa[b][0]
    update val
  */
  return fa[a][0];
 
}
int getdist(int a, int b) {
  return dep[a] + dep[b] - 2 * dep[lca(a, b)];
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Matrix
class Matrix {
#define MAX (5)
  private:
    ll mt[MAX][MAX];
    int order = 2;
  public:
    int Order()const {
      return order;
    }
    Matrix() {
      setO(order);
    }
    Matrix(int _order) { //0矩阵
      order = _order;
      assert(order <= MAX);
      setO(order);
    }
    Matrix(vector<ll> a) { // n行 1列的矩阵
      assert(!a.empty());
      order = (int)a.size();
      for(int i = 0; i < order; i ++)
        mt[i][0] = a[i];
    }
    void setOrder(int _order) {
      order = _order;
      assert(order <= MAX);
    }
    void setO(int k) { //0矩阵
      order = k;
      for(int i = 0; i < k; i ++)
        for(int j = 0; j < k; j ++)
          mt[i][j] = 0;
    }
    void setE(int k) { //单位阵
      order = k;
      for(int i = 0; i < k; i ++)
        for(int j = 0; j < k; j ++)
          mt[i][j] = i == j ? 1 : 0;
    }
    void set_item(int i, int j, ll k) {
      assert(i < order), assert(j < order);
      mt[i][j] = k;
    }
    ll &operator() (int i, int j) {
      assert(i < order && j < order);
      return mt[i][j];
    }
    void scan() {
      for(int i = 0; i < order; i ++)
        for(int j = 0; j < order; j ++)
          scanf("%lld", &mt[i][j]);
    }
    void print() {
      for(int i = 0; i < order; i ++) {
        for(int j = 0; j < order; j ++)
          printf("%lld ", mt[i][j]);
        puts("");
      }
    }
    friend Matrix operator*(Matrix &A, Matrix &B) {
      int n = A.Order();
      assert(A.Order() == B.Order());
      Matrix C(n);
 
      //  for(int i = 0; i < n; i ++)
      //		for(int j = 0; j < n; j ++)
      //			for(int k = 0; k < n; k ++)
      //				C(i,j) += A(i,k) * B(k,j);
 
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          for(int k = 0; k < n; k ++)
            C(i,j) += A(i,k) * B(k,j) % MOD, C(i,j) %= MOD;
      return C;
    }
    friend Matrix qpow(Matrix A,ll b) {
      Matrix rt(A.Order());
      rt.setE(A.Order());
      while(b) {
        if(b & 1)rt = rt * A;
        b >>= 1;
        A = A * A;
      }
      return rt;
    }
#undef MAX
};
 
 
 
class Linear_Recursive_Sequences { //低阶线性递推数列
  private:
    Matrix A;//转移方程
  public:
    void setA(const Matrix& _A) {
      A = _A;
    }
    Matrix get_ith_AccordingTo_jth(Matrix J, ll j, ll i) { // x[j] --> x[i]
      /*
      J :
      x[j        ] 0 ... 0 0 0
      x[j - 1    ] 0 ... 0 0 0
      .....        0 ... 0 0 0
      x[j - n + 1] 0 ... 0 0 0
      */
      assert(i >= j);
      Matrix B = qpow(A, i - j);
      Matrix res = B * J;
      return res;
    }
} L;
 
 
 
 
 
 
 
 
 
 
 
 
 
//MaxCost EK
const int N = 1e5 + 22, M = 6e6 + 22;
const ll INF = 1e18;
struct Max_Cost_EK {
  int n, S, T;
  int idx, ne[M], h[N], e[M];
  ll f[M], w[M];
 
  bool st[N];
  int q[N], pre[N];
  ll d[N], incf[N];
  void Init(int _S, int _T, int _n) {
    assert(_n < N);
    S = _S, T = _T, n = _n;
    idx = 0;
    for (int i = 0; i <= n; i ++) {
      h[i] = -1;
    }
  }
 
  void add(int a, int b, ll c, ll d) {
    e[idx] = b, f[idx] = c, w[idx] =  d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
    assert(idx < M);
  }
 
  bool spfa() {
    int hh = 0, tt = 1;
    for (int i = 0; i <= n; i ++)
      d[i] = -INF, incf[i] = 0;
    q[0] = S, d[S] = 0, incf[S] = INF;
    while(hh != tt) {
      int t = q[hh ++];
      if(hh == N)
        hh = 0;
      st[t] = false;
 
      for (int i = h[t]; ~i; i = ne[i]) {
        int ver = e[i];
        if(f[i] && d[ver] < d[t] + w[i]) {
          d[ver] = d[t] + w[i];
          pre[ver] = i;
          incf[ver] = min(f[i], incf[t]);
          if(!st[ver]) {
            q[tt ++] = ver;
            if(tt == N) tt = 0;
            st[ver] = true;
          }
        }
      }
    }
    return incf[T] > 0;
  }
 
  void EK(ll &flow, ll &cost) {
    flow = cost = 0;
    while(spfa()) {
      int t = incf[T];
      flow += t, cost += t * d[T];
      for(int i = T; i != S; i = e[pre[i] ^ 1]) {
        f[pre[i]] -= t;
        f[pre[i] ^ 1] += t;
      }
    }
  }
} G;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//MaxFlow_Dinic
 
const int N = 20050, M = 600050;//边要开两倍！！！！！！
const double INF = 1e18, eps = 1e-6;
struct MaxFlow {
  int idx, n;
  int S, T;
  int h[N], ne[M], e[M];
  int cur[N], d[N];
  double f[M]; //残余网络容量
  double cap[M]; //源网络容量， 仅做保存，用于还原 原图的流量
  MaxFlow(int s = 0, int t = 0, int _n = 0) { //n为总点数
    Init(s, t, _n);
    assert(_n < N);
  }
  void Init(int s = 0, int t = 0, int _n = 0) {
    S = s, T = t, n = _n;
    idx = 0;
    assert(n < N);
    for(int i = 0; i <= n; i ++)
      h[i] = -1;
  }
  void set_ST(int s, int t) {
    S = s, T = t;
  }
  void add(int a, int b, double c) {
//    de(a), de(b), de2(c);
    cap[idx] = c;
    e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx ++;
    e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx ++;
    assert(idx < M);
  }
  bool bfs() {
    queue<int> q;
    for(int i = 0; i <= n; i ++)
      d[i] = -1;
    q.push(S), d[S] = 0, cur[S] = h[S];
    while(q.size()) {
      int t = q.front();
      q.pop();
      if(t == T)
        return true;
      for(int i = h[t]; ~i; i = ne[i]) {
        int j = e[i];
        if(d[j] == -1 && f[i] > eps) {
          d[j] = d[t] + 1;
          q.push(j);
          cur[j] = h[j];
        }
      }
    }
    return false;
  }
  double find(int u, double
              limit) { //limit表示S到u流量最小值，所以考虑下一条边的时候，只有当流出去的流量小于limit才能继续流
    if(u == T)return limit;
    double flow = 0;
    for(int i = cur[u]; ~i && flow < limit; i = ne[i]) {
      cur[u] = i;// 当前弧优化
      int j = e[i];
      if(d[j] == d[u] + 1 && f[i] > eps) {
        double t = find(j, min(f[i], limit - flow));
        if(!t)
          d[j] = -1;
        f[i] -= t, f[i ^ 1] += t, flow += t;
      }
    }
    return flow;
  }
 
  double dinic() {
    assert(S != T);
    double res = 0, flow;
    while(bfs()) { // 只要增广路径存在，通过bfs建出分层图
      while(flow = find(S, INF))
        //通过find找出所有能增广的路径 第二个参数表示已经经过的最大的容量 返回最小的找出来后，S到T最小的流量
        res += flow;
    }
    return res;
  }
 
  //正向边
  bool is_Forward(int x) {
    assert(x >= 0 && x < idx);
    return x % 2 == 0;
  }
 
  bool vis[N];
  void DFS(int u) {
    vis[u] = 1;
    for(int i = h[u]; ~i; i = ne[i]) {
      int j = e[i];
      if(f[i] > eps && !vis[j])
        DFS(j);
    }
  }
  vector<int> MinCut() {
    for(int i = 0; i <= n; i ++)
      vis[i] = false;
    DFS(S);
    vector<int> res;
    for(int i = 0; i <= n; i ++) {
      if(vis[i])
        res.push_back(i);
    }
    return res;
  }
} G;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//MinCost EK
 
const int N = 1e5 + 22, M = 6e6 + 22;
const ll INF = 1e18;
struct Min_Cost_EK {
  int n, S, T;
  int idx, ne[M], h[N], e[M];
  ll f[M], w[M];
 
  bool st[N];
  int q[N], pre[N];
  ll d[N], incf[N];
  void Init(int _S, int _T, int _n) {
    assert(_n < N);
    S = _S, T = _T, n = _n;
    idx = 0;
    for (int i = 0; i <= n; i ++) {
      h[i] = -1;
    }
  }
 
  void add(int a, int b, ll c, ll d) {
    e[idx] = b, f[idx] = c, w[idx] =  d, ne[idx] = h[a], h[a] = idx ++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;
    assert(idx < M);
  }
 
  bool spfa() {
    int hh = 0, tt = 1;
    for (int i = 0; i <= n; i ++)
      d[i] = INF, incf[i] = 0;
    q[0] = S, d[S] = 0, incf[S] = INF;
    while(hh != tt) {
      int t = q[hh ++];
      if(hh == N)
        hh = 0;
      st[t] = false;
 
      for (int i = h[t]; ~i; i = ne[i]) {
        int ver = e[i];
        if(f[i] && d[ver] > d[t] + w[i]) {
          d[ver] = d[t] + w[i];
          pre[ver] = i;
          incf[ver] = min(f[i], incf[t]);
          if(!st[ver]) {
            q[tt ++] = ver;
            if(tt == N) tt = 0;
            st[ver] = true;
          }
        }
      }
    }
    return incf[T] > 0;
  }
 
  void EK(ll &flow, ll &cost) {
    flow = cost = 0;
    while(spfa()) {
      int t = incf[T];
      flow += t, cost += t * d[T];
      for(int i = T; i != S; i = e[pre[i] ^ 1]) {
        f[pre[i]] -= t;
        f[pre[i] ^ 1] += t;
      }
    }
  }
} G;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Miller Rabin
#define int128 __int128
using namespace std;
long long rng(long long x) {
  return (long long)rand() * rand() % x;
}
long long qpow(long long a, long long b, long long p) {
  long long res = 1 % p;
  while(b) {
    if(b & 1)
      res = (int128)res * a % p;
    a = (int128)a * a % p;
    b >>= 1;
  }
  return res;
}
bool Miller_Rabin(long long n) {
  if(n == 1)
    return false;
  else if(n == 2)
    return true;
  else if(n % 2 == 0)
    return false;
  long long a = n - 1;
  int b = 0;
  while(a % 2 == 0)
    a /= 2, b ++;
  const int test_time = 10;
  for (int i = 1; i <= test_time; i ++) {
    long long x = rng(n - 2) + 2;
    long long v = qpow(x, a, n);
    if(v == 1)
      continue;
    int j;
    for (j = 0; j < b; j ++) {
      if(v == n - 1)
        break;
      v = (int128)v * v % n;
    }
    if(j >= b) {
      return false;
    }
  }
  return true;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//ODT
/*ODT 把相同值的区间 用一个<l, r, v> 保存 表示[l, r]里面所有值都是v*/
struct ODT {
  struct Node {
    ll l, r;
    mutable ll v; // 这里mutable要写不然可能会CE
    Node(ll l, ll r, ll v) : l(l), r(r), v(v) {} // 构造函数
    bool operator<(const Node &o) const {
      return l < o.l;  // 重载小于运算符
    }
  };
  set<Node> tree;
  auto split(ll pos) {
    auto it = tree.lower_bound(Node(pos, 0, 0));
    if (it != tree.end() && it->l == pos)
      return it;
    it--;
    ll l = it->l, r = it->r, v = it->v;
    tree.erase(it);
    tree.insert(Node(l, pos - 1, v));
    return tree.insert(Node(pos, r, v)).first;
  }
  void assign(ll l, ll r, ll v) { //区间推平
    auto end = split(r + 1), begin = split(l); // 顺序不能颠倒，否则可能RE
    tree.erase(begin, end); // 清除一系列节点
    tree.insert(Node(l, r, v)); // 插入新的节点
  }
  void modify(ll l, ll r, ll v) {
    auto end = split(r + 1);
    for (auto it = split(l); it != end; it++) {
      it->v;
    }
  }
  ll query(ll l, ll r) {
    auto end = split(r + 1);
    for (auto it = split(l); it != end; it++) {
      it->v;
    }
  }
  void build(ll l, ll r) {
    tree.clear();
    tree.insert(Node(l, r, /*init value*/));
  }
} sg;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//阶
vector<int> fj(int x) {
  vector<int> ans;
  for (int i = 2; 1LL * i * i <= x; i ++) {
    if(x % i == 0) {
      while(x % i == 0)x /= i;
      ans.push_back(i);
    }
  }
  if(x > 1)
    ans.push_back(x);
  return ans;
}
int Phi(int x) {
  auto ps = fj(x);
  int ans = x;
  for (auto p : ps)
    ans = ans / p * (p - 1);
  return ans;
}
 
int Ord(int a, int p, int phip, vector<int> &phip_ps) {
// a mod p 的阶 ps为phi(p)分解出来的质因子
// a ^ phi(p) = 1 mod p
// 令 d = phip 不停的除去ps中的素数即可
  assert(__gcd(a, p) == 1);
  int d = phip;
  for (auto x : phip_ps) {
    while(d % x == 0 && qpow(a, d / x, p) == 1)
      d /= x;
  }
  return d;
}
 
int main() {
  int p;
  cin >> p;
  int phip = Phi(p);
  vector<int> ps = fj(phip);
  int tt;
  cin >> tt;
  while(tt --) {
    int a;
    scanf("%d", &a);
    printf("%d\n", Ord(a, p, phip, ps));
  }
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
// Rho
#define int128 __int128
namespace Factors {
  long long n;
  long long max_factor;
  vector<pair<long long, int>> res;
  long long gcd(long long a, long long b) {
    if (b == 0) return a;
    return gcd(b, a % b);
  }
 
  long long qpow(long long x, long long p, long long mod) {  // 快速幂
    long long ans = 1;
    while (p) {
      if (p & 1) ans = (int128)ans * x % mod;
      x = (int128)x * x % mod;
      p >>= 1;
    }
    return ans;
  }
 
  bool Miller_Rabin(long long p) {  // 判断素数
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (p == 3) return 1;
    long long d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
    for (long long k = 0; k < 10; ++k) {
      long long a = rand() % (p - 2) + 2;
      long long x = qpow(a, d, p);
      if (x == 1 || x == p - 1) continue;
      for (int i = 0; i < r - 1; ++i) {
        x = (__int128)x * x % p;
        if (x == p - 1) break;
      }
      if (x != p - 1) return 0;
    }
    return 1;
  }
 
  long long Pollard_Rho(long long x) {
    long long s = 0, t = 0;
    long long c = (long long)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    long long val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
      for (step = 1; step <= goal; ++step) {
        t = ((__int128)t * t + c) % x;
        val = (__int128)val * abs(t - s) % x;
        if ((step % 127) == 0) {
          long long d = gcd(val, x);
          if (d > 1) return d;
        }
      }
      long long d = gcd(val, x);
      if (d > 1) return d;
    }
  }
  void fac(long long x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {              // 如果x为质数
      res.push_back({x, 0});
      max_factor = max(max_factor, x);  // 更新答案
      while(n % x == 0)
        n /= x;
      return;
    }
    long long p = x;
    while (p >= x) p = Pollard_Rho(x);  // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p);  // 继续向下分解x和p
  }
  long long get_maxfactor(long long x) {
    assert(x >= 2);
    n = x;
    res.clear();
    max_factor = 0;
    fac(x);
    return max_factor;
  }
  vector<pair<long long, int>> get_factors(long long x) {
    assert(x >= 2);
    n = x;
    res.clear();
    long long y = x;
    while(1) {
      max_factor = 0;
      fac(n);
      if(n == 1)
        break;
    }
    sort(res.begin(), res.end());
    res.erase(unique(res.begin(), res.end()), res.end());
    for (auto &pi : res) {
      pi.second = 0;
      while(y % pi.first == 0)
        pi.second ++, y /= pi.first;
    }
    return res;
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//原根
vector<int> fj(int x) {
  vector<int> ans;
  for (int i = 2; 1LL * i * i <= x; i ++) {
    if(x % i == 0) {
      while(x % i == 0)x /= i;
      ans.push_back(i);
    }
  }
  if(x > 1)
    ans.push_back(x);
  return ans;
}
int Phi(int x) {
  auto ps = fj(x);
  int ans = x;
  for (auto p : ps)
    ans = ans / p * (p - 1);
  return ans;
}
 
int min_primitive_root(int p) { // mod p 的最小原根  g 满足 ord(g, p) = phi(p)
  int phip = Phi(p);
  vector<int> phip_ps = fj(phip);
 
  auto ck = [&](int g) {
    if(__gcd(g, p) != 1)
      return false;
    assert(qpow(g, phip, p) == 1);
    for (auto x : phip_ps) {
      if(phip % x == 0 && qpow(g, phip / x, p) == 1)
        return false;
    }
    return true;
  };
 
  for (int g = 1; g < p; g ++) {
    if(ck(g))
      return g;
  }
  return -1;
}
 
vector<int> get_all_primitive_root(int p) { //所有原根
  int g = min_primitive_root(p);
  if(g == -1)
    return vector<int> {};
  int phip = Phi(p);
  vector<int> ans;
  for (int i = 1; i <= phip; i ++) {
    if(__gcd(i, phip) == 1)
      ans.push_back(qpow(g, i, p));
  }
  sort(ans.begin(), ans.end());
  return ans;
}
 
int main() {
  int tt;
  cin >> tt;
  while(tt --) {
    int n, d;
    scanf("%d%d", &n, &d);
    vector<int> alls = get_all_primitive_root(n);
    printf("%d\n", SZ(alls));
    for (int i = 1; i <= SZ(alls) / d; i ++) {
      printf("%d ", alls[i * d - 1]);
    }
    puts("");
  }
//  while(tt --){
//    int p;
//    scanf("%d", &p);
//    printf("%d\n", min_primitive_root(p));
//  }
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
// Seg
const int N = 1e6 + 500;
struct Segment_Tree {
  struct Node {
    int l, r;
    ll tg = /*default value*/;
    bool need = false;
  } tr[N * 4];
#define ls(x) x << 1
#define rs(x) x << 1 | 1
 
  void pushup(Node &rt, Node &lson, Node &rson) {
    rt.l = lson.l, rt.r = rson.r;
 
    /*merge*/
  }
 
  void build(int u, int l, int r) {
    tr[u].l = l, tr[u].r = r;
    tr[u].tg = /*default value*/;
    tr[u].need = false;
    if(l == r) {
      /*set initial val*/
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid), build(rs(u), mid + 1,r);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void build(int l, int r) {
    build(1, l, r);
  }
 
  void build(int u, int l, int r, vector<ll> &a) {
    tr[u].l = l, tr[u].r = r;
    tr[u].tg = /*default value*/;
    tr[u].need = false;
    if(l == r) {
      /*set initial val*/
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void build(int l, int r, vector<ll> &a) {
    build(1, l, r, a);
  }
 
  void build(int u, int l, int r, ll a[]) {
    tr[u].l = l, tr[u].r = r;
    tr[u].tg = /*default value*/;
    tr[u].need = false;
    if(l == r) {
      /*set initial val*/
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void build(int l, int r, ll a[]) {
    build(1, l, r, a);
  }
 
  void MakeTg(int u, ll c) {
    /*modify val*/
 
    tr[u].need = true;
    tr[u].tg/*modify tag*/;
  }
 
  void pushdown(int u) {
    if(tr[u].need == false)
      return;
    MakeTg(ls(u), tr[u].tg), MakeTg(rs(u), tr[u].tg);
    tr[u].tg = /*default val*/;
    tr[u].need = false;
  }
 
  void modify(int u, int ql, int qr, ll c) {
    if(ql > qr)
      return ;
    if(tr[u].l >= ql && tr[u].r <= qr)
      return MakeTg(u, c), void();
    int mid = (tr[u].l + tr[u].r) >> 1;
    pushdown(u);
    if(ql <= mid)
      modify(ls(u), ql, qr, c);
    if(qr >  mid)
      modify(rs(u), ql, qr, c);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void modify(int ql, int qr, ll c) {
    modify(1, ql, qr, c);
  }
 
  void change(int u, int x, ll c) {
    if(tr[u].l == x && tr[u].r == x) {
      /*modify value*/
      return ;
    }
    pushdown(u);
    int mid = (tr[u].l + tr[u].r) >> 1;
    if(x <= mid)
      change(ls(u), x, c);
    if(x >  mid)
      change(rs(u), x, c);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void change(int x, ll c) {
    change(1, x, c);
  }
 
  Node query(int u, int ql, int qr) {
    if(ql > qr)
      return tr[4 * N - 2];
    if(tr[u].l >= ql && tr[u].r <= qr)
      return tr[u];
    pushdown(u);
    int mid = (tr[u].l + tr[u].r) >> 1;
    if(qr <= mid)
      return query(ls(u), ql, qr);
    else if(ql > mid)
      return query(rs(u), ql, qr);
    auto lson = query(ls(u), ql, qr);
    auto rson = query(rs(u), ql, qr);
    Node rt;
    pushup(rt, lson, rson);
    return rt;
  }
  Node query(int ql, int qr) {
    return query(1, ql, qr);
  }
};
//--------------------------------seg
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//RMQ 无修改
const int N = 1e6 + 500;
const ll INF = 1e18;
 
struct Segment_Tree {
  struct Node {
    int l, r;
    int ls, rs;
    ll mx = -INF;
    ll mn = INF;
  } tr[N * 4];
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
  int idx = 0, root = 0;
  void pushup(Node &rt, Node &lson, Node &rson) {
    rt.l = lson.l, rt.r = rson.r;
    rt.mx = max(lson.mx, rson.mx);
    rt.mn = min(lson.mn, rson.mn);
    /*merge*/
  }
 
  void build(int &u, int l, int r) {
    u = ++idx;
    tr[u].l = l, tr[u].r = r;
    if(l == r) {
      /*set initial val*/
      tr[u].mx = tr[u].mn = 0;
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid), build(rs(u), mid + 1,r);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void Build(int l, int r) {
    clear();
    build(root, l, r);
  }
 
  void build(int &u, int l, int r, vector<ll> &a) {
    u = ++idx;
    tr[u].l = l, tr[u].r = r;
    if(l == r) {
      /*set initial val*/
      tr[u].mx = tr[u].mn = a[l];
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void Build(int l, int r, vector<ll> &a) {
    clear();
    build(root, l, r, a);
  }
 
  void build(int &u, int l, int r, ll a[]) {
    u = ++idx;
    tr[u].l = l, tr[u].r = r;
    if(l == r) {
      /*set initial val*/
      tr[u].mx = tr[u].mn = a[l];
      return ;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
    pushup(tr[u], tr[ls(u)], tr[rs(u)]);
  }
  void Build(int l, int r, ll a[]) {
    clear();
    build(root, l, r, a);
  }
 
  Node query(int u, int ql, int qr) {
    if(ql > qr)
      return tr[4 * N - 2];
    if(tr[u].l >= ql && tr[u].r <= qr)
      return tr[u];
    int mid = (tr[u].l + tr[u].r) >> 1;
    if(qr <= mid)
      return query(ls(u), ql, qr);
    else if(ql > mid)
      return query(rs(u), ql, qr);
    auto lson = query(ls(u), ql, qr);
    auto rson = query(rs(u), ql, qr);
    Node rt;
    pushup(rt, lson, rson);
    return rt;
  }
  Node Query(int ql, int qr) {
    return query(root, ql, qr);
  }
 
  void clear() {
    idx = 0, root = 0;
  }
 
} sg;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//seg 任意base
const int N = 1e6 + 500;
typedef long long ll;
class Segment_Tree {
    struct Node {
      int l, r;
      int ls, rs;
      ll tg = /*default value*/;
      bool need = false;
    } tr[N * 4];
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
    int idx = 0, root = 0;
    void pushup(Node &rt, Node &lson, Node &rson) {
      rt.l = lson.l, rt.r = rson.r;
 
      /*merge*/
    }
 
    void build(int &u, int l, int r) {
      u = ++idx;
      tr[u].l = l, tr[u].r = r;
      tr[u].tg = /*default value*/;
      tr[u].need = false;
      if(l == r) {
        /*set initial val*/
        return ;
      }
      int mid = (tr[u].l + tr[u].r) >> 1;
      build(ls(u), l, mid), build(rs(u), mid + 1,r);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    void build(int &u, int l, int r, vector<ll> &a) {
      u = ++idx;
      tr[u].l = l, tr[u].r = r;
      tr[u].tg = /*default value*/;
      tr[u].need = false;
      if(l == r) {
        /*set initial val*/
        return ;
      }
      int mid = (tr[u].l + tr[u].r) >> 1;
      build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    void build(int &u, int l, int r, ll a[]) {
      u = ++idx;
      tr[u].l = l, tr[u].r = r;
      tr[u].tg = /*default value*/;
      tr[u].need = false;
      if(l == r) {
        /*set initial val*/
        return ;
      }
      int mid = (tr[u].l + tr[u].r) >> 1;
      build(ls(u), l, mid, a), build(rs(u), mid + 1,r, a);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    void MakeTg(int u, ll c) {
      /*modify val*/
 
      tr[u].need = true;
      tr[u].tg/*modify tag*/;
    }
 
    void pushdown(int u) {
      if(tr[u].need == false)
        return;
      MakeTg(ls(u), tr[u].tg), MakeTg(rs(u), tr[u].tg);
      tr[u].tg = /*default val*/;
      tr[u].need = false;
    }
 
    void modify(int u, int ql, int qr, ll c) {
      if(ql > qr)
        return ;
      if(tr[u].l >= ql && tr[u].r <= qr)
        return MakeTg(u, c), void();
      int mid = (tr[u].l + tr[u].r) >> 1;
      pushdown(u);
      if(ql <= mid)
        modify(ls(u), ql, qr, c);
      if(qr >  mid)
        modify(rs(u), ql, qr, c);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    void change(int u, int x, ll c) {
      if(tr[u].l == x && tr[u].r == x) {
        /*modify value*/
        tr[u].cnt = c;
        return ;
      }
      pushdown(u);
      int mid = (tr[u].l + tr[u].r) >> 1;
      if(x <= mid)
        change(ls(u), x, c);
      if(x >  mid)
        change(rs(u), x, c);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    Node query(int u, int ql, int qr) {
      if(ql > qr)
        return tr[4 * N - 2];
      if(tr[u].l >= ql && tr[u].r <= qr)
        return tr[u];
      pushdown(u);
      int mid = (tr[u].l + tr[u].r) >> 1;
      if(qr <= mid)
        return query(ls(u), ql, qr);
      else if(ql > mid)
        return query(rs(u), ql, qr);
      auto lson = query(ls(u), ql, qr);
      auto rson = query(rs(u), ql, qr);
      Node rt;
      pushup(rt, lson, rson);
      return rt;
    }
    void clear() {
      idx = 0, root = 0;
    }
}
 
 
 
 
 
 
 
 
 
 
 
 
//Seg 动态开点
const int N = 2e6 + 500; //一般能开多大开多大
 
struct Segment_Tree {
#define ls(x) tr[x].ls
#define rs(x) tr[x].rs
  struct Node {
    int ls, rs;
    int val;
    int tg;
  } tr[N];
  int size;
  inline void New(int &nw) {
    nw = ++size;
  }
 
  void pushup(int u) {
    //merge the value of lson and rson to root
  }
 
  void pushdown(int u, int nl, int nr) {
    //transform tag of root to lson and rson
 
    //modify value of lson and rson
 
    //restore the tag of root
  }
 
  void modify(int &nw, int nl, int nr, int ql, int qr, int c) {
    if (ql > qr)return ;
    if (!nw)New(nw);
    if (nl >= ql && nr <= qr) {
      //modify the tag of root
 
      //modify the value of root
 
      return ;
    }
    pushdown(nw, nl, nr);
    int mid = nl + nr >> 1;
    if (ql <= mid)modify(tr[nw].ls, nl,  mid, ql, qr, c);
    if (qr > mid) modify(tr[nw].rs, mid + 1, nr, ql, qr, c);
    pushup(nw);
  }
  int query(int nw, int nl, int nr, int ql, int qr) {
    if (!nw)return 0;
    if (nl >= ql && nr <= qr)return tr[nw].val;
    pushdown(nw, nl, nr);
    int mid = nl + nr >> 1;
    int rt = 0;
    if (ql <= mid)rt += query(tr[nw].ls, nl,  mid, ql, qr);
    if (qr > mid) rt += query(tr[nw].rs, mid + 1, nr, ql, qr);
    return rt;
  }
};
 
 
 
 
 
 
 
 
 
 
 
 
// Seg persist
 
 
const int N=1e6+500,M=N*25;
 
struct Persisting_Segment_tree {
  struct Node {
    int lson,rson;
    int val;
  } tr[M];
  int root[N];
  int size;
  void copy(int &nw,int u) {
    nw=++size;
    tr[nw]=tr[u];
  }
 
  void build(int &nw,int nl,int nr) {
    nw=++size;
    if(nl==nr) {
      /*tr[nw].val=.....    modify val*/
      return ;
    }
    int mid=nl+nr>>1;
    build(tr[nw].lson,nl,mid),build(tr[nw].rson,mid+1,nr);
  }
 
  void pushup(Node &rt,Node &ls,Node &rs) {
    /*merge val of ls and rs*/
  }
 
  void pushup(int u) {
    pushup(tr[u],tr[tr[u].lson],tr[tr[u].rson]);
  }
 
  void insert(int &nw,int u,int nl,int nr,int x,int c) { //在节点u所在版本上 单点插入一个点
    copy(nw,u);
    if(nl==nr) {
      /*modify val*/
      tr[nw].val=c;
      return ;
    }
    int mid=nl+nr>>1;
    if(x<=mid)insert(tr[nw].lson,tr[u].lson,nl,    mid,x,c);
    if(x>mid) insert(tr[nw].rson,tr[u].rson,mid+1,nr  ,x,c);
    pushup(nw);
  }
 
  int query(int u,int nl,int nr,int x) { //单点查询
    if(nl==x&&nr==x)return x;
    int mid=nl+nr>>1;
    if(x<=mid)return query(tr[u].lson,nl,mid,x);
    if(x>mid)return query(tr[u].rson,mid+1,nr,x);
  }
 
 
 
  Node query(int u,int nl,int nr,int ql,int qr) { //区间查询
    if(nl>=ql&&nr<=qr)return tr[u];
    int mid=nl+nr>>1;
    if(qr<=mid)return query(tr[u].lson,nl,mid,ql,qr);
    else if(ql>mid)return query(tr[u].rson,mid+1,nr,ql,qr);
    else {
      Node &rt=tr[u],&ls=tr[tr[u].lson],&rs=tr[tr[u].rson];
      pushup(rt,ls,rs);
      return rt;
    }
  }
} sg;
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Sieve
const int MN = 2e6 + 22;
int pr[MN];//第i个素数
int p[MN];// p[x] = t   x最小素因子为t
int tol;
void sieve(int n) { //线性筛
  for (int i = 2; i <= n; i ++) {
    if(!p[i])
      p[i] = i, pr[++tol] = i;
    for (int j = 1; j <= tol && pr[j] * i <= n; j ++) {
      p[i * pr[j]] = pr[j]; // gcd(i, pr[j]) = 1
      if(p[i] == pr[j])
        break;
    }
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Sieve2
vector<int> prime;
vector<bool> st;
void get_Prime(int n) {
  st.clear();
  st.resize(n + 1);
  for(int i = 2; i <= n; i ++) {
    if(!st[i])prime.push_back(i), st[i] = 1;
    for(int j = 0; j < (int)prime.size() && prime[j] * i <= n; j ++) {
      st[i * prime[j]] = 1;
      if(i % prime[j] == 0)
        break;
    }
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//Sieve Product Function   Fast Dirichlet Mul
 
const int N = 2e6 + 222;
int p[N], pr[N / 5], tot;
int pe[N];//pe[n] : n的最小素因子p的幂次为e  pe[n] = p ^ e
int d[N], sgm[N], phi[N], mu[N];
 
void compute(int n, int f[], function<int(int)> calc_pe) {//线性筛积性函数
// calc_pe: f[p ^ e] 和 f[p ^ (e - 1)]的关系   calc_pe(x) assert(x % p[x] == 0)
  f[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (i == pe[i]) f[i] = calc_pe(i);
    else f[i] = f[pe[i]] * f[i / pe[i]];
  }
}
void sieve(int n) {
  p[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (!p[i]) p[i] = i, pe[i] = i, pr[++tot] = i;
    for (int j = 1; j <= tot && pr[j] * i <= n; j++) {
      p[i * pr[j]] = pr[j];
 
      //注，如果是完全积性函数 f 直接在这边筛即可 f[i * pr[j]] = f[i] * f[pr[j]]
      if (p[i] == pr[j]) {
        pe[i * pr[j]] = pe[i] * pr[j];
        break;
      } else {
        pe[i * pr[j]] = pr[j];
      }
    }
  }
}
void Mul(int f[], int g[], int h[],
         int n) { //狄利克雷卷积 h = f * g      f, g任意函数       O(nlogn)
  for (int i = 1; i <= n; i ++)
    h[i] = 0;
  for (int d1 = 1; d1 <= n; d1 ++)
    for (int d2 = 1; d1 * d2 <= n; d2 ++)
      h[d1 * d2] += f[d1] * g[d2];
}
 
//常数大的话可以 把h省略掉， 直接在f上改
void Mul2(int f[], int g[], int h[],
          int n) { //狄利克雷卷积 h = f * g   g必须是积性函数  f无要求 O(nlog(logn))
  for (int i = 1; i <= n; i ++)
    h[i] = f[i];
  for (int i = 1; i <= tot && pr[i] <= n; i ++) {
    for (int j = n / pr[i]; j >= 1; j --) {
      for (ll x = pr[i]; 1LL * j * x <= n; x *= pr[i]) { // x = p ^ e
        h[j * x] += 1LL * h[j] * g[x];
      }
    }
  }
}
 
int main() {
  int n;
  cin >> n;
  sieve(n);
  compute(n, d, [&](int x) { //因子个数， d[p ^ e] = d[p ^ (e - 1)] + 1
    return d[x / p[x]] + 1;
  });
 
  compute(n, sgm, [&](int x) {//因子和    sgm[p ^ e] = sgm[p ^ (e - 1)] + p ^ e
    return sgm[x / p[x]] + x;
  });
 
  compute(n, phi, [&](int x) {//Phi       phi[x] = x / p * (p - 1)
    return x / p[x] * (p[x] - 1);
  });
 
  compute(n, mu, [&](int x) {// mu        phi[p ^ e] = e == 1 ? -1 : 0
    return x == p[x] ? -1 : 0;
  });
}
 
 
 
 
 
 
 
 
 
 
 
//String hash    base0
typedef unsigned long long ull;
const int N = 1e5 + 50;
const int base = 131;
ull p[N];
void initP() { //程序最开始 初始化 ！！！！
  p[0] = 1;
  for(int i = 1; i <= N - 20; i ++)p[i] = p[i - 1] * base;
}
struct StringHash { //index from 0
  int n;
  string str;
  ull h[N];
  void init() {
    n = (int)str.size();
    for(int i = 0; i < n; i ++) {
      if(i != 0)
        h[i] = h[i - 1] * base + ull(str[i] - 'a' + 1);
      else
        h[i] = ull(str[i] - 'a' + 1);
    }
  }
  ull get_hash(int x,int y) {
    if(x == 0)
      return h[y];
    return ull(h[y] - h[x - 1] * p[y - x + 1]);
  }
};
/*string hash*/
 
 
 
 
 
 
 
 
 
 
 
 
 
//String hash  base1
typedef unsigned long long ull;
const int N = 1e5 + 50;
const int base = 131;
ull p[N];
void initP() { //程序最开始 初始化 ！！！！
  p[0] = 1;
  for(int i = 1; i <= N - 20; i ++)p[i] = p[i - 1] * base;
}
struct StringHash { //index from 1
  int n;
  char str[N];
  ull h[N];
  void init() {
    n = strlen(str + 1);
    for(int i = 1; i <= n; i ++)
      h[i] = h[i - 1] * base + ull(str[i] - 'a' + 1);
  }
  ull get_hash(int x,int y) {
    return ull(h[y] - h[x - 1] * p[y - x + 1]);
  }
};
 
 
 
 
 
 
 
 
 
 
 
//Tarjan E_DCC
const int N = 1e6 + 22, M = 2e6 + 22;
int n, idx, e[M], ne[M], h[N];
int dfn[N], low[N], ti;
int stk[N], top;
int id[N], dcc_cnt; //每个点属于哪个双连通分量
bool is_bridge[M];
int deg[N]; //缩点后度数
void Init() {
  for(int i = 0; i < idx; i ++)
    is_bridge[i] = false;
  for(int i = 0; i <= n; i ++) {
    dfn[i] = low[i] = 0, h[i] = -1, deg[i] = 0;
  }
  ti = 0;
  top = 0;
  idx = 0;
  dcc_cnt = 0;
}
void add(int a, int b) {
  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void Tarjan(int u, int from = -1) { //防止搜反向边
  dfn[u] = low[u] = ++ti;
  stk[++top] = u;
 
  for(int i = h[u]; ~i; i = ne[i]) {
    int j = e[i];
    if(!dfn[j]) {
      Tarjan(j, i);
      ckmin(low[u], low[j]);
      if(dfn[u] < low[j])
        is_bridge[i] = is_bridge[i ^ 1] = true;
    } else if(i != (from ^ 1))
      ckmin(low[u], dfn[j]);
  }
  if(dfn[u] == low[u]) {
    ++ dcc_cnt;
    int y;
    do {
      y = stk[top --];
      id[y] = dcc_cnt;
    } while(y != u);
  }
}
int main() {
  int m;
  scanf("%d%d", &n, &m);
  Init();
  for(int i = 1; i <= m; i ++) {
    int a, b;
    scanf("%d%d", &a, &b);
    add(a, b), add(b, a);
  }
  for(int i = 1; i <= n; i ++)
    if(!dfn[i])
      Tarjan(i);
  for(int i = 0; i < idx; i ++) {
    if(is_bridge[i])
      deg[id[e[i]]] ++;
  }
  int z = 0;
  for(int i = 1; i <= dcc_cnt; i ++)
    z += deg[i] == 1;
  cout << (z + 1) / 2 << "\n";
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//Tarjan SCC
const int N = 1e6 + 500;
 
/* tarjan */
int n, m, times, top, scc_cnt;
vector < int > e[N], e2[N], id, stk, in_stk, dfn, low, scc_ind, scc_oud;
void Init(int n) {
  times = top = scc_cnt = 0;
  for(int i = 1; i <= n; i ++ )e[i].clear(), e2[i].clear();
  id.clear(), stk.clear(), in_stk.clear(), dfn.clear(), low.clear(), scc_ind.clear(), scc_oud.clear();
  id.resize(n + 1), stk.resize(n + 1), in_stk.resize(n + 1), dfn.resize(n + 1), low.resize(n + 1),
            scc_ind.resize(n + 1), scc_oud.resize(n + 1);
}
void add(int a, int b) {
  e[a].push_back(b);
}
 
void add2(int a, int b) {
  e2[a].push_back(b);
}
 
void tarjan(int u) {
  dfn[u] = low[u] = ++ times;
  stk[ ++ top] = u;
  in_stk[u] = 1;
  for(auto j : e[u]) {
    if(!dfn[j]) {
      tarjan(j);
      low[u] = min(low[u], low[j]);
    } else if(in_stk[j])low[u] = min(low[u], dfn[j]);
  }
  if(dfn[u] == low[u]) {
    ++ scc_cnt;
    int y;
    do {
      y = stk[top -- ];
      id[y] = scc_cnt;
      in_stk[y] = 0;
    } while(y != u);
  }
}
void build_Scc_Graph() {
  for(int u = 1; u <= n; u ++ ) {
    for(auto j : e[u]) {
      if(id[j] != id[u]) {
        add2(id[u], id[j]);
        scc_oud[id[u]] ++ ;
        scc_ind[id[j]] ++ ;
      }
    }
  }
}
/* tarjan */
 
int ans[N];
int main() {
  scanf("%d%d", &n, &m);
  Init(n);
  for(int i = 1; i <= m; i ++ ) {
    int a, b;
    scanf("%d%d", &a, &b);
    add(a, b);
  }
  for(int i = 1; i <= n; i ++ )if(!dfn[i])tarjan(i);
  build_Scc_Graph();
  int f = -1;
  int num = 0;
  for(int i = 1; i <= scc_cnt; i ++ )if(!scc_oud[i])num ++ , f = i;
  if(num >= 2) {
    puts("0");
    return 0;
  }
  int res = 0;
  for(int i = 1; i <= n; i ++ )if(id[i] == f)res ++ ;
  cout << res << "\n";
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//Tarjan VDCC
 
const int N = 2e5 + 100;
const int M = 4e6 + 100;
 
struct Egde {
  int to, next;
} edge1[M], edge2[M];
 
int head1[N], head2[N], low[N], dfn[N], belong[N], Stack[N], new_id[N], num, cnt, cnt1, cnt2, tot,
    root, top, n, m;
int deg[N];
bool cut[N];
 
vector<int>dcc[N];
 
void addedge(int u, int v) {
  edge1[cnt1].to = v;
  edge1[cnt1].next = head1[u];
  head1[u] = cnt1++;
}
 
void addedge2(int u, int v) {
  edge2[cnt2].to = v;
  edge2[cnt2].next = head2[u];
  head2[u] = cnt2++;
}
 
void tarjan(int u) {
  dfn[u] = low[u] = ++num;
  Stack[++top] = u;
  if (u == root && head1[u] == -1) {
    dcc[++cnt].push_back(u);
    return;
  }
  int flag = 0;
  for (int i = head1[u]; i != -1; i = edge1[i].next) {
    int v = edge1[i].to;
    if (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
      if (low[v] >= dfn[u]) {
        flag++;
        if (u != root || flag > 1)
          cut[u] = true;
        cnt++;
        int x;
        do {
          x = Stack[top--];
          dcc[cnt].push_back(x);
        } while (x != v);
        dcc[cnt].push_back(u);
      }
    } else
      low[u] = min(low[u], dfn[v]);
  }
}
int block;
void solve() {
  for (int i = 1; i <= n; i++) //找割点+缩点
    if (!dfn[i]) {
      root = i;
      tarjan(i);
      block ++;
    }
}
 
void build() { //缩点+连边
  solve();
  num = cnt;
  for (int i = 1; i <= n; i++)
    if (cut[i])
      new_id[i] = ++num;// 所有割点单独看成一个点
  for (int i = 1; i <= cnt; i++)
    for (auto x : dcc[i]) {
      if (cut[x]) {
        addedge2(i, new_id[x]);
        addedge2(new_id[x], i);
        deg[new_id[x]] ++;
        deg[i] ++;
      } else
        belong[x] = i;
    }
}
 
void Init() {
  for (int i = 0; i <= n; i++)
    dcc[i].clear();
  cnt = cnt2 = cnt1 = num = tot = top = 0;
  for(int i = 0; i <= n; i ++)
    head2[i] = head1[i] = -1, low[i] = dfn[i] = belong[i] = Stack[i] = new_id[i] = 0, cut[i] = 0,
                                       deg[i] = 0;
}
 
int main() {
  int m;
  cin >> n >> m;
  Init();
  for(int i = 1; i <= m; i ++) {
    int a, b;
    scanf("%d%d", &a, &b), addedge(a, b), addedge(b, a);
  }
  int q;
  cin >> q;
  if(n == 2) {
    for(int i = 1; i <= q; i ++)
      puts("YES");
    return 0;
  }
  solve();
  build();
 
  bool ok = 1;
  for(int i = 1; i <= num; i ++)
    if(deg[i] > 2)
      ok = 0;
//  for(int i = 1; i <= n; i ++)
//    printf("%d -> %d\n",i, cut[i]);
  while(q --) {
    int x, y;
    cin >> x >> y;
    if(block > 1 || !ok)
      puts("NO");
    else {
      if(cut[x] || cut[y])
        puts("NO");
      else {
        if(cnt == 1)
          puts("YES");
        else {
          puts(belong[x] != belong[y] && deg[belong[x]] == 1 && deg[belong[y]] == 1
               ? "YES" : "NO");
        }
      }
    }
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//Persist Trie
 
struct Persisting_Trie {
#define N 100000
  int size;
  struct Node {
    int son[2];
    int val;
    int cnt;
  } tr[N * 32];
  int root[N];
#undef N
  void New(int &nw) {
    nw = ++size;
  }
  void copy(int &nw, int u) {
    nw = ++size;
    tr[nw] = tr[u];
  }
  void insert(int &nw, int u, int x, int cur) { //当前在nw，在u节点所在的版本上加，
    if (u == 0)New(nw);
    else copy(nw, u);
    if (cur == -1) {
      tr[nw].val = x;
      tr[nw].cnt++;
      return ;
    }
    int c = x >> cur & 1;
    insert(tr[nw].son[c], tr[u].son[c], x, cur - 1);
  }
 
 
  int query(int u, int x, int cur) {
    if (cur == -1)return tr[u].cnt;
    int c = x >> cur & 1;
    if (tr[u].son[c])return query(tr[u].son[c], x, cur - 1);
    else return 0;
  }
} T;
 
 
 
 
 
 
 
 
 
 
 
 
 
//杜教筛
 
const int N = 5e6;
int p[N], pr[N / 5], tot;//注意 n不能太小
int pe[N];//pe[n] : n的最小素因子p的幂次为e  pe[n] = p ^ e
 
void sieve(int n) {
  p[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (!p[i]) p[i] = i, pe[i] = i, pr[++tot] = i;
    for (int j = 1; j <= tot && pr[j] * i <= n; j++) {
      p[i * pr[j]] = pr[j];
 
      //注，如果是完全积性函数 f 直接在这边筛即可 f[i * pr[j]] = f[i] * f[pr[j]]
      if (p[i] == pr[j]) {
        pe[i * pr[j]] = pe[i] * pr[j];
        break;
      } else {
        pe[i * pr[j]] = pr[j];
      }
    }
  }
}
void compute(int n, ll f[], ll sf[], function<ll(ll)> calc_pe) {//线性筛积性函数
// calc_pe: f[p ^ e] 和 f[p ^ (e - 1)]的关系   calc_pe(x) assert(x % p[x] == 0)
  f[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (i == pe[i]) f[i] = calc_pe(i);
    else f[i] = f[pe[i]] * f[i / pe[i]];  // % MOD
  }
  for (int i = 1; i <= n; i ++)
    sf[i] = sf[i - 1] + f[i]; // % MOD
}
 
struct Product_Functions_Prefix_Sum {
//private:
  ll v[N], sv[N];// sv[k] = v[1] + .... + v[k]
  unordered_map<ll, ll> sum;
  function<ll(ll)> sumg, sumfg;// f的前缀和  f * g 的前缀和
  function<ll(ll)> calv;// v的线性筛
//public:
  ll operator[](ll x) {
    if(x < N)
      return v[x];
    else
      return getsum(x) - getsum(x - 1);
  }
  void Init(function<ll(ll)> _calv, function<ll(ll)> _sumg, function<ll(ll)> _sumfg) {
    calv = _calv, sumg = _sumg, sumfg = _sumfg;
    compute(N - 1, v, sv, calv);
  }
  ll getsum(ll n) { //
    if(n < N)
      return sv[n];
    if(sum.count(n))
      return sum[n];
    ll res = sumfg(n);
    for (ll l = 2, r; l <= n; l = r + 1) { // 这里是long long  从2开始
      ll v = n / l;
      r = n / v;
      res -= getsum(v) * (sumg(r) - sumg(l - 1)); // % MOD
    }
    return sum[n] = res;
  }
} phi, mu, sgm, d;
 
 
int main() {
  sieve(N - 1);
//  phi.
  phi.Init([&](ll x) {
    return x / p[x] * (p[x] - 1);
  },
  [&](ll x) {
    return x;
  },
  [&](ll x) {
    return x * (x + 1) / 2;
  });
  mu.Init([&](ll x) {
    return x == p[x] ? -1 : 0;
  },
  [&](ll x) {
    return x;
  },
  [&](ll x) {
    return 1;
  });
  sgm.Init([&](ll x) {
    return sgm[x / p[x]] + x;
  },
  [&](ll x) {
    return mu.getsum(x);
  },
  [&](ll x) {
    return x * (x + 1) / 2;
  });
  for (int i = 1; i <= 20; i ++) {
    de(i), de(sgm[i]), de(sgm.getsum(i)), puts("");
  }
  int tt;
  scanf("%d", &tt);
  while(tt --) {
    ll n;
    scanf("%lld", &n);
    printf("%lld %lld\n", phi.getsum(n), mu.getsum(n));
  }
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//马拉车
 
const int N = 2e6 + 10;
 
int n;
char a[N], b[N];
int radius[N];//radius[x] = t, b数组中以x为中心 的 最大回文子串的半径长度 ，即 [x - t + 1,x + t - 1]为 中心为x的回文子串
 
void init() {
  int k = 0;
  b[k ++ ] = '$', b[k ++ ] = '#';
  for (int i = 0; i < n; i ++ ) b[k ++ ] = a[i], b[k ++ ] = '#';
  b[k ++ ] = '^';
  n = k;
}
 
void manacher() {
  int mr = 0, mid;
  for (int i = 1; i < n; i ++ ) {
    if (i < mr) radius[i] = min(radius[mid * 2 - i], mr - i);
    else radius[i] = 1;
    while (b[i - radius[i]] == b[i + radius[i]]) radius[i] ++ ;
    if (i + radius[i] > mr) {
      mr = i + radius[i];
      mid = i;
    }
  }
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//n元集中大小为k的子集
 
void show(int x, int n) {
  for(int i = n - 1; i >= 0; i --)
    printf("%d", (x >> i) & 1);
  puts("");
}
void work(int n, int k) {
  int lim = (1 << n);
  int cur = (1 << k) - 1;
  while(cur < lim) {
    show(cur, n);
    int lbt = cur & -cur;
    int r = cur + lbt;
    cur = ((r ^ cur) >> (__builtin_ctz(lbt) + 2)) | r;
  }
}
 
int main() {
  work(6, 3);
  return 0;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//模拟退火
 
#include <ctime>
#include <cstdlib>
vector<PII> a;
int n;
 
double rng(double a, double b) {
  return a + (b - a) * rand() / RAND_MAX;
}
/*simulate anneal*/
double ans = 1e8;
double f(pair<double, double> p) {
  double rt = 0;
  for (int i = 0; i < n; i ++) //这里 不开根号更好，误差更低
    rt = rt + sqrt((p.first - a[i].first) * (p.first - a[i].first) + (p.second - a[i].second) *
                   (p.second - a[i].second));
  ans = min(ans, rt); //最值在这边更新比较保险 ！！！！
  return rt;
}
void simulate_anneal() {
 
  const double alpha = 0.99;
  for (int tt = 1; tt <= 100; tt ++) { // 强转 double ！！！！！！
    pair<double, double>cur(rng(0, 10000), rng(0, 10000));
    for (double T = 10000 / 2; T > 1e-4; T = T * alpha) {
      pair<double, double> P(rng(cur.first - T, cur.first + T), rng(cur.second - T, cur.second + T));
      double delta = f(P) - f(cur);
      if (exp(-delta / T) > rng(0, 1)) 最小值   这里delta和T差的过大时，要乘一个系数
        /*exp(delta / T) > rd(0, 1) 最大值*/
        cur = P;
    }
  }
  //	printf("clock = %.2lf\n",(double)clock() / CLOCKS_PER_SEC);
  printf("%d\n", (int)(ans + 0.5));
}
/*simulate anneal*/
 
 
//上下取整
 
ll DownDiv(ll a, ll b) {
  assert(b);
  if (a % b == 0)
    return a / b;
  if (a > 0)
    return a / b;
  return a / b - 1;
}
ll UpDiv(ll a, ll b) {
  assert(b);
  if (a % b == 0)
    return a / b;
  if (a > 0)
    return a / b + 1;
  return a / b;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
//实数三分
 
const double eps = 1e-10;
vector<double> a;
int n;
double cal(double x) {
  double cur = 1;
  double rt = 0;
  for(int i = 0; i <= n; i ++) {
    rt += a[i] * cur;
    cur = cur * x;
  }
  return rt;
}
int main() {
  double l,r;
  cin >> n >> l >> r;
  for(int i = 0; i <= n; i ++) {
    double c;
    cin >> c;
    a.push_back(c);
  }
  reverse(a.begin(),a.end());
 
  /*三分板子*/
  while(l + eps < r) {
    double lm = l + (r - l) / 3,rm = r - (r - l) / 3;
    if(cal(lm) <= cal(rm))l = lm + eps;
    else r = rm - eps;
  }
  cout << l;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
//替罪羊树
const int N = 1.1e6 + 22;
const double Alpha = 0.75;
template<typename T>
struct Scapegoat_Tree {
  int root, idx;
  int ls[N], rs[N];
  T v[N];
  int cnt[N], s[N], sd[N], sz[N];
  int seq[N], tol;
  void ReBuild_DFS(int u) {
    if(!u)
      return;
    ReBuild_DFS(ls[u]);
    if(cnt[u])
      seq[++tol] = u;
    ReBuild_DFS(rs[u]);
  }
  void ReBuild(int &u, int l, int r) {
    if(l > r)
      return u = 0, void();
    int mid = (l + r) >> 1;
    u = seq[mid];
    ReBuild(ls[u], l, mid - 1);
    ReBuild(rs[u], mid + 1, r);
    pushup(u);
  }
  void Do_ReBuild(int &u) {
    tol = 0;
    ReBuild_DFS(u);
    ReBuild(u, 1, tol);
  }
 
  void build() {
    root = 0;
    idx = 0;
  }
  void pushup(int u) {
    s[u] = s[ls[u]] + s[rs[u]] + 1;
    sd[u] = sd[ls[u]] + sd[rs[u]] + (cnt[u] != 0);
    sz[u] = sz[ls[u]] + sz[rs[u]] + cnt[u];
  }
  bool Bad(int u) {
    return cnt[u] && (max(s[ls[u]], s[rs[u]]) >= Alpha * s[u] || sd[u] <= Alpha * s[u]);
  }
  void NewNode(int &u, T val) {
    u = ++idx;
    cnt[u] = 1;
    v[u] = val;
    s[u] = sd[u] = sz[u] = 1;
    ls[u] = rs[u] = 0;
  }
  void Insert(int &u, T val) {
    if(!u)
      return NewNode(u, val), void();
    if(val == v[u])
      cnt[u] ++;
    else if(val < v[u])
      Insert(ls[u], val);
    else
      Insert(rs[u], val);
    pushup(u);
    if(Bad(u))
      Do_ReBuild(u);
  }
  void Insert(T val) {
    Insert(root, val);
  }
 
  void Remove(int &u, T val) {
    if(!u)
      return;
    if(val == v[u]) {
      if(cnt[u])
        cnt[u] --;
    } else if(val < v[u])
      Remove(ls[u], val);
    else
      Remove(rs[u], val);
    pushup(u);
    if(Bad(u))
      Do_ReBuild(u);
  }
  void Remove(T val) {
    Remove(root, val);
  }
 
  int Get_Smaller_Cnt(int u, T val) {
    if(!u)
      return 0;
    else if(val == v[u])
      return sz[ls[u]];
    else if(val < v[u])
      return Get_Smaller_Cnt(ls[u], val);
    else
      return sz[ls[u]] + cnt[u] + Get_Smaller_Cnt(rs[u], val);
  }
  int Get_Smaller_Cnt(T val) {
    return Get_Smaller_Cnt(root, val);
  }
 
  T Get_Val_By_Rank(int u, int rank) {
    if(!u)
      return numeric_limits<T>::max();
    if(rank <= sz[ls[u]])
      return Get_Val_By_Rank(ls[u], rank);
    else if(rank <= sz[ls[u]] + cnt[u])
      return v[u];
    else
      return Get_Val_By_Rank(rs[u], rank - sz[ls[u]] - cnt[u]);
  }
  T Get_Val_By_Rank(int rank) {
    return Get_Val_By_Rank(root, rank);
  }
 
  T Get_Pre(T x) {
    return Get_Val_By_Rank(Get_Smaller_Cnt(x));
  }
  T Get_Suf(T x) {
    return Get_Val_By_Rank(Get_Smaller_Cnt(x + 1) + 1);
  }
};
 
 
 
 
 
 
 
 
 
 
//树链剖分
int n, m, root, MOD;
int tim;
vector < vector < int >> e;
vector < int > dfn, sz, fa, top, son, d;
void init() {
  tim = 0;
  dfn.clear(), sz.clear(), fa.clear(), top.clear(), son.clear(), d.clear();
  dfn.resize(n + 1), sz.resize(n + 1), fa.resize(n + 1), top.resize(n + 1), son.resize(n + 1),
             d.resize(n + 1);
  e.clear();
  e.resize(n + 1);
}
 
void dfs1(int u, int dep, int f) {
  fa[u] = f, d[u] = dep, sz[u] = 1;
  for(auto j : e[u]) {
    if(j == f)
      continue;
    dfs1(j, dep + 1, u);
    sz[u] += sz[j];
    if(sz[son[u]] < sz[j])
      son[u] = j;
  }
}
void dfs2(int u, int tp) {
  dfn[u] = ++ tim;
  top[u] = tp;
  if(son[u])
    dfs2(son[u], tp);
  else
    return ;
  for(auto j : e[u]) {
    if(j == fa[u] || j == son[u])
      continue;
    dfs2(j, j);
  }
}
 
 
 
const int N = 1e6 + 22;
class Segment_Tree {
  private:
    struct Node {
      int l, r;
      ll tg = /*default value*/;
      bool need = false;
    } tr[N * 4];
#define ls(x) x << 1
#define rs(x) x << 1 | 1
 
    void pushup(Node &rt, Node &lson, Node &rson) {
      rt.l = lson.l, rt.r = rson.r;
 
      /*merge*/
    }
 
    void build(int u, int l, int r) {
      tr[u].l = l, tr[u].r = r;
      tr[u].tg = /*default value*/;
      tr[u].need = false;
      if(l == r) {
        /*set initial val*/
        return ;
      }
      int mid = (tr[u].l + tr[u].r) >> 1;
      build(ls(u), l, mid), build(rs(u), mid + 1,r);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    void MakeTg(int u, ll c) {
      /*modify val*/
 
      tr[u].need = true;
      tr[u].tg/*modify tag*/;
    }
 
    void pushdown(int u) {
      if(tr[u].need == false)
        return;
      MakeTg(ls(u), tr[u].tg), MakeTg(rs(u), tr[u].tg);
      tr[u].tg = /*default val*/;
      tr[u].need = false;
    }
 
    void modify(int u, int ql, int qr, ll c) {
      if(ql > qr)
        return ;
      if(tr[u].l >= ql && tr[u].r <= qr)
        return MakeTg(u, c), void();
      int mid = (tr[u].l + tr[u].r) >> 1;
      pushdown(u);
      if(ql <= mid)
        modify(ls(u), ql, qr, c);
      if(qr >  mid)
        modify(rs(u), ql, qr, c);
      pushup(tr[u], tr[ls(u)], tr[rs(u)]);
    }
 
    Node query(int u, int ql, int qr) {
      if(ql > qr)
        return tr[4 * N - 2];
      if(tr[u].l >= ql && tr[u].r <= qr)
        return tr[u];
      pushdown(u);
      int mid = (tr[u].l + tr[u].r) >> 1;
      if(qr <= mid)
        return query(ls(u), ql, qr);
      else if(ql > mid)
        return query(rs(u), ql, qr);
      auto lson = query(ls(u), ql, qr);
      auto rson = query(rs(u), ql, qr);
      Node rt;
      pushup(rt, lson, rson);
      return rt;
    }
 
  public:
    void Build(int l, int r) {
      build(1, l, r);
    }
 
    void Modify(int ql, int qr, ll c) {
      modify(1, ql, qr, c);
    }
 
    Node Query(int ql, int qr) {
      return query(1, ql, qr);
    }
} sg;
 
void modify_path(int u, int v, ll c) {
  while(top[u] != top[v]) {
    if(d[top[u]] < d[top[v]])
      swap(u, v);
    sg.Modify(dfn[top[u]], dfn[u], c);
    u = fa[top[u]];
  }
  if(d[u] < d[v])
    swap(u, v);
  sg.Modify(dfn[v], dfn[u], c);
}
ll query_path(int u, int v) {
  ll rt =/*default value*/;
  while(top[u] != top[v]) {
    if(d[top[u]] < d[top[v]])
      swap(u, v);
 
    rt /*update rt*/ sg.Query(dfn[top[u]], dfn[u]);
 
    u = fa[top[u]];
  }
  if(d[u] < d[v])
    swap(u, v);
  rt /*update rt*/ sg.Query(dfn[v], dfn[u]);
 
  return rt;
}
void modify_tree(int u, ll c) {
  sg.Modify(dfn[u], dfn[u] + sz[u] - 1, c);
}
ll query_tree(int u) {
  return sg.Query(dfn[u], dfn[u] + sz[u] - 1). /*???*/;
}
int main() {
  scanf("%d%d%d%d",  &n,  &m,  &root,  &MOD);
  init();
  for(int i = 1; i <= n; i ++ )
    scanf("%d", w + i);
  for(int i = 1; i < n; i ++ ) {
    int a, b;
    scanf("%d%d",  &a,  &b);
    e[a].push_back(b), e[b].push_back(a);
  }
  dfs1(root, 1,  - 1);
  dfs2(root, root);
  sg.Build(1, n);
  for(int i = 1; i <= n; i ++ )
    modify_path(i, i, w[i]);
  for(int i = 1; i <= m; i ++ ) {
    int op, x, y, z;
    scanf("%d",  &op);
    if(op == 1) {
      scanf("%d%d%d",  &x,  &y,  &z);
      modify_path(x, y, z);
    } else if(op == 2) {
      scanf("%d%d",  &x,  &y);
      printf("%lld\n", query_path(x, y));
    } else if(op == 3) {
      scanf("%d%d",  &x,  &z);
      modify_tree(x, z);
    } else {
      scanf("%d",  &x);
      printf("%lld\n", query_tree(x));
    }
  }
  return 0;
}
 
 
 
//整数三分
 
int l = 0,r = d;
while(l < r) {
 
  int lm = l + (r - l) / 3;
  //int rm = l + 2 * (r - l) / 3; // 这样写是不对的 ！！！！！！
  int rm = r - (r - l) / 3;
  //printf("%d %d   %d %d\n",l,r,lm,rm);
  ll la = cal(lm),ra = cal(rm);
 
  if(la > ra/*la > ra 有多个峰时取最前面的，写成 la >= ra取最后面的*/)l = lm + 1;//这边一定要加一
  else r = rm - 1;//一定要减1
}
 
 
 
 
 
 
 
```

